64bit x86_64 APIs are Magic But Not The Way You Think
=====================================================

This is probably going to confuse the hell out of a lot of people, but what if I told you that for most applications you ever write, can now write them in portable 64 bit assembler?<br><br>I discovered this factoid on porting an old application I started writing in NASM for building on YASM on Mac OS X 10.9.  The original system I wrote the code on was a Mac OS X 10.5 machine, and I had implemented a set of scripts which generated assembler macros based on the /usr/include/sys/*.h header files.  I could in theory call every BSD syscall underlying the Mac operating system, and this means I had access to files, network sockets, memory allocation, and raw hardware.  It turns out that you don&#39;t need a lot of code to do the typical things you do to write things like a web server.  For example I could make a HTTP request in assembler using little more than socket, bind, connect, read, and write.  I also wrote a bare bones web server with socket, bind, listen, accept, read and write.  These are incredibly small programs, and since they don&#39;t include anything like libc or the like, they start and stop nearly instantly.<br><br>The trickiest thing to do is actually understand what the C libraries are expecting as their data structures.  The horrific struct sockaddr_in* used by bind, connect, sendto, and recvfrom looks like:<br><pre><br>sockaddr:<br>        .size:    db 0<br>        .family:  db 2<br>        .port:    db 0x1F,0x90<br>        .ipaddr:  db 0,0,0,0<br>        .padding: dq 0<br></pre><br>In this example, I have a PF_INET (AF_INET) socket listening on IPv4&#39;s 0.0.0.0 (IN_ADDR_ANY) address on port 0x1f90 (8080 http-alt). This code is no more difficult than the C code, and actually is much much easier to understand what is going on.  Since .port and .ipaddr are in network byte order, it turns out that it is really easy to change things like .ipaddr, just write the number separated by , instead of . and you&#39;re done: 127,0,0,1 instead of htonl(127 << 24 + 1); <br><br>Similarly all of your syscalls are going to look like:<br><pre><br>_socket:<br>            mov rdi, 2      ; PF_INET<br>            mov rax, socket<br>            syscall<br>            mov r12, rax    ; store fd in r12 as it is preserved across syscalls<br>            ret<br></pre><br>Where the registers are going to follow this scheme:<br><pre><br>; rax = syscall<br>; rdi = arg1<br>; rsi = arg2<br>; rdx = arg3<br>; r10 = arg4        ; rcx on 10.5 or sooner<br>; r8  = arg5<br>; r9  = arg6<br></pre><br>What shocked me was that my code was only broken because of a ABI breakage on Mac OS X, where they went from using rcx to pass arg4 to the OS to using r10, which is the same as Linux.  This standardization meant that with a small script:<br><pre><br>cat /usr/include/sys/syscall.h | grep -v "old " | grep "^#define" | sed &#39;s%#define%\\%define%&#39; | sed &#39;s%SYS_%%&#39; | sed &#39;s%$$% + 0x2000000%&#39; | tail -n +3 > syscall.asm<br></pre><br>I could generate a macros for all of the posix calls on Mac OS X, and a second script:<br><pre><br>cat /usr/include/asm/unistd_64.h | grep -v "old " | grep "^#define" | sed &#39;s%#define%\\%define%&#39; | sed &#39;s%__NR_%%&#39; | tail -n +2<br></pre><br>Does the same for Linux.  With only some minor tweaks on specific data structures like those used by fstat, the code for both operating systems is nearly identical.  I have very few places in the code where there are %ifdef %else  macro blocks to customize the behavior to a specific operating system.  My largest assembler project has only 2 points where I had to resort to that.  And when you think about that, the sum different between the two platforms is:<ul><li>the object format (macho64 vs elf64)</li><li>the syscall numbers</li><li>a few data structures and their alignment</li></ul><br>And you&#39;ll realize that assembler has become much more portable.  That said, as soon as you want to venture into the realms that make each OS unique, you&#39;re SOL.  Part of the reason I have projects like my Framebuffer Server, is to ignore the difference between the OSes, by virtualizing the OS device interface.  Since the OS is standing between me and the hardware, I&#39;ve decided to build virtual devices that work like the hardware interfaces I wish I had access to.  This further removes the differences.  Hopefully I&#39;ll soon release my Audio Server, and be able to play PCM data by dd&#39;ing to a file.  But since I have<br>assembler support for mmapping a shared file, I can always code my version in assembler.  And since projects like <a href="http://libsdl.org">SDL</a> make it easy to program cross platform multi-media applications, I can run my virtual devices on both Mac OS X and Linux.<br><br>