Smarter Javascript
==================

One of the things I&#39;ve been working on in my spare time is a reformulation of Javascript, so as to make it less <i>squiggly</i>.  If you look at JS code, it involves far too much punctuation.  All of the () {} and [] mixed in with . and , and : just makes for very busy code.  It becomes hard to appreciate the quality of code with so much graphical noise breaking up a sentence.  If you were trying to speak such code at a computer, you&#39;d end up with a horrible parody of a Victor Borge routine.  So what does this new Javascript look like?<br /><br /><blockquote><pre><br />An object named &#39;Device&#39; plural &#39;Devices&#39; from <br />   dispatch: { action, event |  <br />       App widgets every { widget |  <br />                if (widget can action) widget.action event<br />        }<br />   }<br /></pre></blockquote><br /><br />So what has changed?  Well quite a bit.  Here&#39;s the equivalent code in current JS:<br /><br /><blockquote><pre><br />An.object().named(&#39;Device&#39;).plural(&#39;Devices&#39;).from({<br />       dispatch : function(action,event) {<br />                App.widgets.every(function(widget) { <br />                        if (widget.can(action)) widget[action](event);<br />                });<br />       },<br />})<br /></pre></blockquote><br /><br />This is already pretty clean for JS code in general, and because of how it is written can be evaluated within a single eval() statement.   But if you compare the two listings, you can see how much of a difference a few punctuation marks can make.  By changing the rules regarding how methods dispatches are designated in the language syntax, quite a bit of the structure of the language can be eliminated.  So how do we get from JS as it stands today to this new nomenclature?<br /><br /><ul><br /><li><b>:</b> is an operator that binds a name to a value</li><br /><li><b>,</b> is an operator that produces an array</li><br /><li><b>{ | }</b> produces a closure binding the tokens before the | to local variables</li><br /><li><b>.</b> is an operator that does a key lookup based on the value passed on its right hand side.</li><br /><li><b>;</b> is an operator that performs the equivalent of <i>( a && false) || b</i></li><br /><li>method application is the default operation when two words are adjacent</li><br /><li>every function takes zero or one value, which may be an object or array of objects, and always returns a value</li><br /><li>by default, most functions will return this, if no other value is produced</li><br /><li>arrays and strings may be indexed by passing them a number, much like objects get &#39;passed&#39; a method name</li><br /></ul><br /><br />The effects of these changes are profound on how one writes code.  Chaining methods is done through the mere aggregation of method names.  Many of the more complex things you can do with dynamic dispatch are much more cleanly expressed.  Additionally, strings, arrays, and objects function much more like functions, which take a value (integer in the case of strings and arrays, strings in the case of objects) and return a new value.   And the style of programming morph greatly when one looks at lexical binding as a replacement for assignment.  For example, let&#39;s say I want to replace an <i>App</i> object&#39;s <i>delay</i> value with a new one.  What I would have typically writen is:<br /><br /><blockquote><pre><br />App.delay = 20;<br /></pre></blockquote><br /><br />The new formulation, however, would either use a binding operator or a property copying function which would copy the properties of an object passed to it:<br /><br /><blockquote><pre><br />App delay : 20<br /><br />or as<br /> <br />App has delay : 20<br /></pre></blockquote><br /><br />You could write the same thing in existing Javascript using a function like:<br /><br /><blockquote><pre><br />Object.prototype.has = function(o) {<br />   for (var k in o) if (o.hasOwnProperty(k)) this[k] = o[k];<br />  return this;<br />}<br /><br />App.has({ delay: 20 });<br /></pre></blockquote><br /><br />The big win in this style of programming comes when you want to set a large number or properties at a time.  For example, take the case of some graphical object properties.  You may want to create a new rectangle with specific dimensions, at a particular coordinate in 3D space, and with a given RGBA color.<br /><br /><blockquote><pre><br />A rectangle has x : 100 , y : 200, z : 300 , width : 20 , height: 30, red : 255 , green : 0 , blue : 128, alpha :192<br /></pre></blockquote><br /><br />Using the formulation that works in existing JS you would write that using the above <i>has</i> method as:<br /><br /><blockquote><pre><br />A.rectangle().has({ x : 100 , y : 200, z : 300 , width : 20 , height: 30, red : 255 , green : 0 , blue : 128, alpha : 129 })<br /></pre></blockquote><br /><br />But if you were more conventionally minded, you might have done the same thing but written code like:<br /><br /><blockquote><pre><br />var rect = new Rectangle();<br />rect.x = 100;<br />rect.y = 200;<br />rect.z = 300;<br />rect.width = 20;<br />rect.height = 30;<br />rect.red = 255;<br />rect.green = 0;<br />rect.blue = 128;<br />rect.alpha = 192;<br /></pre></blockquote><br /><br />which clearly shows a lack of appreciation for the finer points of language like Javascript.  By reformulating how Javascript is parsed and perceived, quite a few of the fiddly bits can be removed.  The resulting language is clean and conceptually elegant.  Using some clever semantics, the code can be made much more humane and legible, with little harm done to its conciseness.  By focusing on saying things the way you&#39;d like to say them, rather than how you "have" to say it, you can both reduce the quantity of documentation necessary to make sense of the code, and increase the ease with which future programmers can read it.  <br /><br />Along those lines, I&#39;m also toying with replacing the comment system // and /* */ with requiring all lines of code start with a tab character, and that any lines that don&#39;t begin with a tab are removed as comments.  The resulting <i>literate</i> javascript style looks something like this:<br /><br /><blockquote><pre><br />Draw a rectangular button at (100,200) that if clicked, confirms that the registration information is correct.<br /><br />        A rectangle named &#39;button&#39; has x : 100 , y : 200, width : 200 , height: 30, src : &#39;button.png&#39;, <br />                down: { event | if (event on this) document goto &#39;/confirm?value=true&#39; }<br />          <br /></pre></blockquote><br /><br />Since we can include JS code using AJAX at runtime, it is easy enough to load our code written in this format, parse it, and re-synthesize it into ordinary JS on the fly.  The small upfront cost of performing a rewrite on the client side can also have long lasting benefits, especially in the case of long running JS applications.  By allowing us to write documentation inline like this, and stripping out the code based on indentation, it reduces the likelihood that documentation and code will get out of sync.  It also encourages developers to keep better notes of what they are doing, and avoid doing silly things like:<br /><br /><blockquote><pre><br />   this.id = &#39;foo&#39;; // set the id of the HTML element to &#39;foo&#39;<br />   this.style.display = &#39;none&#39;;  // hide the element by setting its CSS display property to none.<br />  }                            // end of function <br />} // end of if<br /></pre></blockquote><br /><br />These sorts of comments are merely meaningless lip service to the idea of documenting your code, and yet they tend to be the norm whenever code gets commented.  When the code changes, these comments tend to get messed up, especially if a comment spans multiple lines, and the resulting change is not reflected in the comment.  The "end of function" vs "end of if" block comments above are indicative of this sort of sloppiness, and is found all to commonly in production code.<br /><br />Hopefully, over the next couple weeks, as the parser get cleaned up and finalized, I&#39;ll release a version of it on Github, with sufficient examples of how the new syntax can encourage better OO technique, and improve the legibility and semantics of your code.