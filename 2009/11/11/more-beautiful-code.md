More Beautiful Code
===================

<blockquote>693 dollar 1993 Ford Taurus</blockquote><br /><br />You can read that and probably have a good idea of what I mean.  It isn&#39;t the greatest code in the world, but it is declaring an object you can probably picture in your head, rusted bodywork, dented fender, bumper stickers, pale teal paint job and all.  You don&#39;t need any additional information to determine what class it belongs to, <i>car</i>, and are pretty familiar with its publicly defined APIs: <i>steering wheel</i>, <i>stick or automatic</i>, <i>gas pedal</i>, <i>break</i>.<br /><br /><blockquote> ((693 dollar) (1993 (Ford (Taurus)))) -> a (car)</blockquote><br /><br />That&#39;s probably along the lines of how you&#39;d likely parse it as some form of syntax tree, to transform it into something more manageable.  If you were thinking of it in terms of Smalltalk, this would represent a absolutely horrific extension on the basic numeric classes.  If you were to make the modifications to those classes though your code would more likely look something like:<br /><br /><blockquote>693 dollar: ((1993 Ford) Taurus)</blockquote><br /><br />Where dollar: would take an object, and associate it with the value 693.  Ford would be a constructor which would generate a Car object with the model year of 1993, and the Taurus method would merely specify the internal <i>make</i> member variable.  If one were writing an application that talked about a wide variety of cars in these terms, making these sorts of modifications to the basic Number classes would make some sense.<br /><br /><blockquote>(a Ford Taurus) vs. (the Ford Taurus)</blockquote> <br /><br />Take this formulation for example.  Let&#39;s say we have two global objects called <i>a</i> and <i>the</i> which happen to have the exact same set of methods defined.  In both cases, we define a method <i>Ford</i> which will generate an object which will represent something made by <b>Ford</b>.  We could similarly add methods to generate <i>Chevy</i>, <i>Bugatti</i>, <i>Jaguar</i>, <i>Bentley</i>, and <i>Triumph</i>, with much the same effect, all producing various on the base <i>Car</i> class of objects.  What differs between these two idioms however, is that one uses the <i>indefinite article -- a</i> and the other uses the <i>definite article -- the</i>.  <br /><br /><blockquote>a Ford Taurus -> a pointer to an instance of the class of Ford Taurus objects</blockquote><br /><br />In this example, we use the indefinite nature of the word <i>a</i> to indicate that all of its methods return a pointer to an instance variable, of a class determined by the method invocation.  In English, the indefinite article indicates that <i>some</i> member of the <i>class</i> is being referred to, not necessarily a specific instance.  When I mention, a book, or a car, you are more concerned with that the object I&#39;m talking about fills a given role, rather than which particular object it might be. <br /><br /><blockquote>the Ford Taurus -> a pointer to a global static singluar instance of Ford Taurus</blockquote><br /><br />Other times, we can use the word <i>the</i> to specify a specific object, such as the categorial example, or the example referenced in the current context or scope.  Objects representing <i>the Mouse</i>, <i>the Keyboard</i>, and <i>the Screen</i> or even <i>the Page</i>, are all good cadidates for a singular global entity which may referred to in a wide variety of scopes, but contextually are all the same object.  <br /><br /><blockquote>semantics of use > semantics of implementation</blockquote><br /><br />How we allow the language we use everyday to inform our design decisions directly determines the maintainability of our code.  Or in other words, the semantics of use should take higher precedence over the semantics of implementation.  When you read someone&#39;s code, the question you will most often ask your self is "what does this code do", not the less relevant "how does this code do it".  Information hiding, does not mean we obscure the intent of the programmer behind structure and naming, but rather we allow the reader to focus on the semantics of use, <i>the what</i>.  If one is working with a <i>blackbox</i> one is only focused on <i>the what</i>.  When you are programming on a framework that you can not change, <i>the how</i> of the framework is immaterial.  And if you are designing a framework for other people&#39;s consumption, then you owe it to them to think about your APIs on your user&#39;s terms.