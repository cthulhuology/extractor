Learning to Design
==================

<span class="Apple-style-span" style="font-size: x-large;">Process and Limitations</span><div><br /></div><div>Most of the problems found in the design of software are artificial.  Aside from resource constraints, which are limited by the available technology and the fundamental forces and structure of the universe, all other limitations are the product of the mere aggregation of design decisions.  When you start learning to program, many sagely and experienced programmers will encourage you to learn a language with a wealth of APIs, 3rd party libraries of code, that will make producing a solution easier.  So the common wisdom goes, it is more important to start producing solutions than it is to understand how they work.</div><div><br /></div><div><span class="Apple-style-span" style="font-size: large;">Risk Aversion</span></div><div><br /></div><div>Part of the motivation for this train of thought lies in the business realities most programmers face on a daily basis.  In order to reduce risk, it is better to reuse an old design that is known to work marginally well, than it is to attempt to build a better one.  As it is easy to measure the cost of an existing system, but hard to measure the actual cost of the new design, business logic will favor going with the tried and true.  This is the appeal of operating systems like Windows and Unix, as it is the appeal of languages like Perl, Java, and Smalltalk.  As most of the design decisions concerning how most of the software works have already been made, there is far less room for an inexperienced or foolish programmer to screw it up.</div><div><br /></div><div><span class="Apple-style-span" style="font-size: large;">T</span><span class="Apple-style-span" style="font-size: large;">r</span><span class="Apple-style-span" style="font-size: large;">a</span><span class="Apple-style-span" style="font-size: large;">d</span><span class="Apple-style-span" style="font-size: large;">e</span><span class="Apple-style-span" style="font-size: large;">-</span><span class="Apple-style-span" style="font-size: large;">o</span><span class="Apple-style-span" style="font-size: large;">f</span><span class="Apple-style-span" style="font-size: large;">f</span><span class="Apple-style-span" style="font-size: large;">s</span></div><div><br /></div><div>But what are the trade offs of relying upon these tools?  In what ways do the choices made by other people impact your finished work?  In yesterday&#39;s post, I detailed a process for designing software, in which one repeatedly measures and tests the outcomes of their design decisions.  When it comes to measuring software, there are a few important categories of measurements that should always be tracked each step of the development process:</div><div><ul><li>How many lines of code were written? ( total, per term, per function, per statement, etc)</li><li>How many terms are defined? (variables, functions, classes, methods, etc)</li><li>How much processing time are required by each functional unit? (function, thread, etc)</li><li>How much memory is required? ( for processing, for storage, for I/O buffering, etc)</li></ul><div>The first two sets of measurements deal with the complexity of the solution from a reader&#39;s point of view, the later two from the machine&#39;s.  By using some general rules of thumb, you can judge your designs against reasonable metrics.  Remember that these are not strict rules, but rather guidelines derived from real world experience.  </div><div><br /></div><div><span class="Apple-style-span" style="font-size: large;">L</span><span class="Apple-style-span" style="font-size: large;">i</span><span class="Apple-style-span" style="font-size: large;">n</span><span class="Apple-style-span" style="font-size: large;">e</span><span class="Apple-style-span" style="font-size: large;">s</span><span class="Apple-style-span" style="font-size: large;"> </span><span class="Apple-style-span" style="font-size: large;">o</span><span class="Apple-style-span" style="font-size: large;">f</span><span class="Apple-style-span" style="font-size: large;"> </span><span class="Apple-style-span" style="font-size: large;">C</span><span class="Apple-style-span" style="font-size: large;">o</span><span class="Apple-style-span" style="font-size: large;">d</span><span class="Apple-style-span" style="font-size: large;">e</span></div><div><span class="Apple-style-span" style="font-size: large;"><br /></span></div><div><span class="Apple-style-span" style="font-size: medium;">While many people attempt to compare programming languages by comparing the lines of code produced to solve comparable problems, these comparisons are generally disingenuous.  As a result, there is a general sentiment that counting lines of code is a poor metric by which to judge code quality.  And this is true.  When used to guide your design, on the other hand, lines of code counts can be invaluable for identifying components in need of redesign:</span></div><div><br /></div><div><b>Rule of Thumb 0:<span class="Apple-tab-span" style="white-space:pre"> </span>One line of code per term defined is the ideal.</b></div><div><b><br /></b></div><div><b>Rule of Thumb 1:<span class="Apple-tab-span" style="white-space:pre"> </span>Write no more than 5 lines of code per function on average.</b></div><div><b><br /></b></div><div>People in general are incapable of holding more than a handful of ideas in their heads at any one time.  As such, breaking your problem down into digestible chunks makes it much easier to learn.  And as with the English language, programming languages which allow for multiple clauses to be chained together into more complex sentences, also allow for lower line counts.</div><div><br /></div><div><span class="Apple-style-span"  style="font-size:180%;"><span class="Apple-style-span" style="font-size: 18px;">Vocabulary</span></span></div><div><span class="Apple-style-span"  style="font-size:180%;"><span class="Apple-style-span" style="font-size: 18px;"><br /></span></span></div><div>As you reduce the number of lines of code per function, you will find that the number of user defined functions will also increase.  At a ratio of 5 to 1, a 1000 line program will have approximately, 200 or so functions defined.  The size of the vocabulary of the project is a good indication of the complexity of your solution.  By factoring out common elements, common routines, and common idioms, you effectively compress your source code.  </div><div><br /></div><div><b>Rule of Thumb 2: The ideal solution uses the smallest number of definitions.  </b></div><div><br /></div><div>The size of the vocabulary also determines how hard it is for a new programmer to learn how your software works.  In English, for example, 80% of all written text uses the 2000 most common words.  A college educated American will typically know 15,000-20,000 words well.  It is difficult to learn more than 8-10 or so words well per day.  Software which consists of millions of lines of code is effectively incomprehensible software, as it would take years to learn how it all worked.</div><div><br /></div><div><b>Rule of Thumb 3: Define no more than 2000 terms in a single application.</b></div><div><b><br /></b></div><div>The lower limit of how much complexity can be encapsulated in a single line of code and the upper limit of how many discrete concepts a programmer can easily learn and understand, define the range of well written software.  However, these limitations are not nearly as constraining as one would at first think.  Since definitions can build upon each other, the complexity expressed grows geometrically with each term added.  With 2000 definitions, the total number of possible combinations is so large as to be practically incomprehensible.</div><div><br /></div><div><span class="Apple-style-span" style="font-size: large;">P</span><span class="Apple-style-span" style="font-size: large;">e</span><span class="Apple-style-span" style="font-size: large;">r</span><span class="Apple-style-span" style="font-size: large;">f</span><span class="Apple-style-span" style="font-size: large;">o</span><span class="Apple-style-span" style="font-size: large;">r</span><span class="Apple-style-span" style="font-size: large;">m</span><span class="Apple-style-span" style="font-size: large;">a</span><span class="Apple-style-span" style="font-size: large;">n</span><span class="Apple-style-span" style="font-size: large;">c</span><span class="Apple-style-span" style="font-size: large;">e</span></div><div><span class="Apple-style-span" style="font-size: large;"><br /></span></div><div><span class="Apple-style-span" style="font-size: medium;">O</span><span class="Apple-style-span" style="font-size: medium;">n</span><span class="Apple-style-span" style="font-size: medium;">c</span><span class="Apple-style-span" style="font-size: medium;">e</span><span class="Apple-style-span" style="font-size: medium;"> </span><span class="Apple-style-span" style="font-size: medium;">y</span><span class="Apple-style-span" style="font-size: medium;">o</span><span class="Apple-style-span" style="font-size: medium;">u</span><span class="Apple-style-span" style="font-size: medium;">&#39;</span><span class="Apple-style-span" style="font-size: medium;">v</span><span class="Apple-style-span" style="font-size: medium;">e</span><span class="Apple-style-span" style="font-size: medium;"> </span><span class="Apple-style-span" style="font-size: medium;">m</span><span class="Apple-style-span" style="font-size: medium;">a</span><span class="Apple-style-span" style="font-size: medium;">n</span><span class="Apple-style-span" style="font-size: medium;">a</span><span class="Apple-style-span" style="font-size: medium;">g</span><span class="Apple-style-span" style="font-size: medium;">e</span><span class="Apple-style-span" style="font-size: medium;">d</span><span class="Apple-style-span" style="font-size: medium;"> </span><span class="Apple-style-span" style="font-size: medium;">t</span><span class="Apple-style-span" style="font-size: medium;">o</span><span class="Apple-style-span" style="font-size: medium;"> </span><span class="Apple-style-span" style="font-size: medium;">k</span><span class="Apple-style-span" style="font-size: medium;">e</span><span class="Apple-style-span" style="font-size: medium;">e</span><span class="Apple-style-span" style="font-size: medium;">p</span><span class="Apple-style-span" style="font-size: medium;"> </span><span class="Apple-style-span" style="font-size: medium;">y</span><span class="Apple-style-span" style="font-size: medium;">o</span><span class="Apple-style-span" style="font-size: medium;">u</span><span class="Apple-style-span" style="font-size: medium;">r</span><span class="Apple-style-span" style="font-size: medium;"> </span><span class="Apple-style-span" style="font-size: medium;">c</span><span class="Apple-style-span" style="font-size: medium;">o</span><span class="Apple-style-span" style="font-size: medium;">d</span><span class="Apple-style-span" style="font-size: medium;">e base to a reasonable size, and you can explain what each term means, you&#39;re ready to start worrying about performance.  Many of the performance problems we encounter in software design are rooted in decisions made by the hardware engineers.  For example, if your processor runs at 2GHz, and has a 19 instruction deep pipeline, each instruction will take between 500 and 9500 picoseconds to execute.  These represent the lower limit for the CPU is physically capable of producing.  When you read manufacturer&#39;s benchmarks, they will typically tend towards the idealized 500ps number, and shy away from the 9500 picosecond number.</span></div><div><br /></div><div>If you choose to write software for a popular preemptive multitasking operating system, you also choose additional performance trade-offs.  For example, depending on your processor architecture a Linux kernel will make a task switch in between 24µs and 240µs.  These numbers are derived less from what the CPU is capable of, and more dependent on the speed of the memory bus and size of your executable.  For a high performance webserver, where 10,000 requests per second are expected, 24µs is a substantial portion of the 100µs of available time for processing per client.</div><div><br /></div><div><b>Rule of Thumb 4: Design based on observed timing metrics, not theoretical performance.</b></div><div><b><br /></b></div><div>There are many profiling tools available to monitor the performance of your software.  Some tools like Apple&#39;s Shark allow you to attach to an already running process and monitor its progress over a controllable span of time.  Other tools allow you to monitor performance over the entire life of the program.  It is important to remember that external monitoring tools do impact the performance of your software, and can introduce their own source of errors.  Similarly, adding performance tracking and debugging routines within your application can also directly impact performance.  </div><div><b><span class="Apple-style-span" style="font-weight: normal;"><br /></span></b></div><div>Once you establish what effect your monitoring has on the performance of your application, and can reliably predict the impact different changes to your software will have, you can then design with performance in mind.  Relying upon 3rd party libraries or advanced compilers to provide performance will guarantee failure to produce efficient code.  Similarly, focusing on algorithmic efficiency without empirically studying with real world constraints will also result in poorly performing code.</div><div><br /></div><div><span class="Apple-style-span" style="font-weight: bold; ">Rule of Thumb 5: Optimize critical paths first, and be wary or 3rd party libraries and optimizers.</span></div><div><br /></div><div>For example, on one recent project a microprocessor emulator I was writing was displaying a virtual performance of 8MHz, well below any realistic measure of what it should have done on a 1.8GHz host.  Removing a single debugging statement which periodically logged performance to a file increased the observed performance to 24MHz.  This line consisted of a single standard library fprintf call, yet resulted in a 300% improvement in performance.  Running the code through the profiler, I noticed that one of the 3rd party library routines which periodically checked for skew between the host and simulated system clock was taking way too long.  Examining its implementation, I noticed it used a usleep, or "microsleep" command to ensure synchronization with the hardware clock.  Removing the routine resulted in an additional performance boost from 24MHz to 50MHz, an additional 200% increase.  Rearranging some code such that a series of functions in the critical code path to take advantage of compiler optimizations increased the observed performance gain from 50MHz to 75MHz, a 50% increase.  And applying some further compiler hints as to which functions could be compiled inline boosted performance from 75MHz to 100MHz, a 33% improvement.</div><div><b><br /></b></div><div><span class="Apple-style-span" style="font-size: large;">Bandwidth</span></div><div><span class="Apple-style-span"  style="font-size:180%;"><span class="Apple-style-span" style="font-size: 18px;"><br /></span></span></div><div><span class="Apple-style-span" style="font-size: medium;">I</span><span class="Apple-style-span" style="font-size: medium;">t</span><span class="Apple-style-span" style="font-size: medium;"> </span><span class="Apple-style-span" style="font-size: medium;">i</span><span class="Apple-style-span" style="font-size: medium;">s</span><span class="Apple-style-span" style="font-size: medium;"> </span><span class="Apple-style-span" style="font-size: medium;">n</span><span class="Apple-style-span" style="font-size: medium;">o</span><span class="Apple-style-span" style="font-size: medium;">t</span><span class="Apple-style-span" style="font-size: medium;"> </span><span class="Apple-style-span" style="font-size: medium;">t</span><span class="Apple-style-span" style="font-size: medium;">e</span><span class="Apple-style-span" style="font-size: medium;">r</span><span class="Apple-style-span" style="font-size: medium;">r</span><span class="Apple-style-span" style="font-size: medium;">i</span><span class="Apple-style-span" style="font-size: medium;">b</span><span class="Apple-style-span" style="font-size: medium;">l</span><span class="Apple-style-span" style="font-size: medium;">y</span><span class="Apple-style-span" style="font-size: medium;"> </span><span class="Apple-style-span" style="font-size: medium;">u</span><span class="Apple-style-span" style="font-size: medium;">n</span><span class="Apple-style-span" style="font-size: medium;">u</span><span class="Apple-style-span" style="font-size: medium;">s</span><span class="Apple-style-span" style="font-size: medium;">u</span><span class="Apple-style-span" style="font-size: medium;">a</span><span class="Apple-style-span" style="font-size: medium;">l to hear programmers say silly things like, "who cares memory is cheap!"  They say this especially when trying to justify using programming techniques which supposedly achieve performance at the expense of more memory consumption.  A whole host of technologies, from memory models, to heap allocation routines, to automatic garbage collection have been created to free the programmer from having to think about how they use memory.  In fact, the trend in programming languages has been to remove any concept of RAM from the programmer&#39;s experience.</span></div><div><br /></div><div>Unfortunately, for new programmers trying to learn to program actual computers, these layers of abstraction present a grossly distorted view of reality.  Raw memory may be cheap in economic terms compared to years ago, but it is not raw memory that a programmer should be concerned with, it is memory bandwidth.  Within a computer, there are different speeds of memory.  Historically, remote storage on a server was the slowest, with local disk being the next slowest.  Once data has left on disk cache, over the main system bus, it makes its way to main memory, also known as RAM, or the heap.  From main memory, it travels across a higher speed memory bus to the CPU&#39;s onboard L2 cache memory, and from the CPU&#39;s L2 cache to the full speed L1 cache, and eventually to the register file.  Each of these memories have their own size constraints, bus speeds, and timing latencies.  </div><div><br /></div><div><b>Rule of Thumb 6: Data structures should be designed with cache size and memory bandwidth in mind.</b></div><div><b><br /></b></div><div><b>Rule of Thumb 7: Data should be laid out in memory so that it can be accessed sequentially, not randomly.</b></div><div><b><br /></b></div><div>Developing an appreciation for the physical limitations of your system&#39;s architecture is probably the hardest part of learning to program.  Once you know your CPU&#39;s instruction set, have a firm grasp on instruction timings, and know your way around your tools, learning to design with your hardware, and not around it, takes a lot of practice.  </div><div><br /></div><div>For example, most modern Intel CPUs have 8 cache lines, this means that the can address at most 8 pages of memory simultaneously.  Each cache page of memory consists of 4kB of data (128 cache lines) and each cache line holds only 32 bytes of data.  At any point, the CPU will probably need 2 of the 8 cache lines for accessing instruction memory, and another 2 for addressing the return stack and heap.  As such, your active data structures should ideally fit within 16kB (4 pages), and address no more than 4 distinct 32 byte regions at any one point in  time.  It is only by designing software with these limitations in mind can you avoid wasting time and energy on unproductive designs.</div><div><br /></div><div><span class="Apple-style-span" style="font-size: x-large;">Of Art and Engineering</span></div><div><br /></div><div>Mastering the art of computer programming is more than learning the basics of software engineering.  While the above rules of thumb provide good guidelines for making software engineering decisions, they speak little to the artistic side of the endeavor.  More than just functioning within tolerances, software must also communicate the author&#39;s intent.  It is easy to render code which function, yet which is incomprehensible to everyone.  There are even competitions such as the <a href="http://www.ioccc.org/">IOCCC</a> to render the most illegible yet functional code possible.</div><div><br /></div><div>Learning to design software which is easy to read and maintain requires particular attention to the artistic side of programming.  Engineering discipline alone is not sufficient to write sustainable code, rather it is a function of how well one marries one&#39;s native tongue to the formulation of the solution that determines the code&#39;s long term viability.  Algorithmic elegance never trumps eloquence when it comes to well written code, just as documentation is never a substitute for legible code.</div></div>