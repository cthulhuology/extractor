Beautiful Code
==============

One thing to keep in mind when reading other people&#39;s code is that there is a difference between clever code and simply beautiful code.  Quite a few, very intelligent, astoundingly capable programmers, find themselves, day after day, writing clever and elegant, but ugly as hell code.  It is the sort of code that is a pleasure to write, but you&#39;d rather burn for an eternity than have to spend a week reading it.<div><br /></div><div><span class="Apple-style-span"  style="font-size:large;">Making Reading Code Pleasant</span></div><div><br /></div><div>Face it.  We all have to do it sometime. We all have to read code.  While many programmers feel they can do their jobs with their eyes shut, it often seems that they do.  For example, if you fire up Xcode and start a new OpenGL application for the iPhone, you&#39;ll see some pre-generated code stubbed out to handle the basic tasks of getting a surface setup on which you can display your models.  Here&#39;s a particularly telling piece of code:</div><div><p style="margin: 0.0px 0.0px 0.0px 0.0px; font: 10.0px Monaco"></p><blockquote><p style="margin: 0.0px 0.0px 0.0px 0.0px; font: 10.0px Monaco">eaglLayer.drawableProperties = [<span style="color:#5c2699;">NSDictionary</span> <span style="color:#2e0d6e;">dictionaryWithObjectsAndKeys</span>:</p> <p  style="margin: 0.0px 0.0px 0.0px 0.0px; font: 10.0px Monaco; color:#5c2699;"><span style="color:#000000;">                                        [</span>NSNumber<span style="color:#000000;"> </span><span style="color:#2e0d6e;">numberWithBool</span><span style="color:#000000;">:</span><span style="color:#aa0d91;">NO</span><span style="color:#000000;">], </span>kEAGLDrawablePropertyRetainedBacking<span style="color:#000000;">, </span>kEAGLColorFormatRGBA8<span style="color:#000000;">, </span>kEAGLDrawablePropertyColorFormat<span style="color:#000000;">, </span><span style="color:#aa0d91;">nil</span><span style="color:#000000;">];</span></p><p  style="margin: 0.0px 0.0px 0.0px 0.0px; font: 10.0px Monaco; color:#5c2699;"><span class="Apple-style-span"  style="color:#000000;"><br /></span></p></blockquote><p></p><p  style="margin: 0.0px 0.0px 0.0px 0.0px; font: 10.0px Monaco; color:#5c2699;"><span style="color:#000000;"></span></p><div><span class="Apple-style-span"  style="font-family:Monaco;"><span class="Apple-style-span"  style=" ;font-family:Georgia;">You got that right?  It is all perfectly clear exactly what this code does.  If you&#39;ve never seen Objective-C code before, this might be a little intimidating, but trust me this code follows nearly every convention intended to make code more readable.  For example:</span></span></div><div><ul><li>uses long descriptive variable and function names</li><li>repeats type information in the names of various variable and function names </li><li>prefixes predefined constant values with a <b>k</b></li><li>uses an abbreviated prefix to clearly indicate which framework each constant is from</li></ul><div>By any measures, a great deal of thought went into exactly how to name each element in this line of code.  It is very consistent and makes use of no less than 3 distinct naming conventions.  Now you might ask what is eaglLayer,  but I&#39;ll give you a hint by showing the 2 lines that come before:</div><span class="Apple-style-span" style="font-family: Monaco; color: rgb(92, 38, 153); font-size: 10px; "><p style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font: normal normal normal 10px/normal Monaco; "><span style="color: rgb(92, 38, 153); "></span></p><blockquote><p style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font: normal normal normal 10px/normal Monaco; "><span style="color: rgb(92, 38, 153); ">CAEAGLLayer</span> *eaglLayer = (<span style="color: rgb(92, 38, 153); ">CAEAGLLayer</span> *)<span style="color: rgb(170, 13, 145); ">self</span>.layer;        </p><p style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font: normal normal normal 10px/normal Monaco; ">eaglLayer.<span style="color: rgb(92, 38, 153); ">opaque</span> = <span style="color: rgb(170, 13, 145); ">YES</span>;</p><div></div></blockquote></span><p></p><div><br /></div><div>This clearly demonstrates the power of naming conventions over reason.  For those who don&#39;t know what a CAEAGLLayer is it is a <i>Core Animation Embedded Apple (Open) Graphics Library Layer.  (GL as in OpenGL, which derives from IRIS GL which was the Integrated Raster Imaging System Graphics Library).</i>  Now the reason we&#39;re typecasting this into a new pointer is that the view&#39;s base layer is a CALayer (Core Animation Layer), and as such does not provide access to the extended <b>drawableProperties</b> parameter our CAEAGLLayer actually has.</div><div><br /></div><div>How do we know that our layer is actually a CAEAGLLayer and not just a plain ordinary CALayer?  Well we don&#39;t, we&#39;re just assuming this, and hoping somewhere, hidden in some configuration file, we set the initialization to the right thing.  That&#39;s ok, it is all just black magic, and you&#39;d never know this from reading any of the actual code.  There&#39;s a comment that hints at it though:</div><div><br /></div><div><p style="margin: 0.0px 0.0px 0.0px 0.0px; font: 10.0px Monaco; color: #007400"></p><blockquote>//The GL view is stored in the nib file. When it&#39;s unarchived it&#39;s sent -initWithCoder:</blockquote><p></p></div><div>And if you look through the nib file long enough you might just find out how this thing is initialized, but since the nib file was also auto-generated, and is edited using a GUI most novice Objective-C developers would just pull their hair out, not understanding why something does or doesn&#39;t work.  Nevermind this comment is actually a bit misleading as the terms <i>stored </i> and <i>unarchived</i> don&#39;t exactly mean what you&#39;d think they mean.  As for what a <i>Coder</i> is, that&#39;s better left to another blog post entirely.</div><div><br /></div><div><span class="Apple-style-span" style="font-size: large;">W</span><span class="Apple-style-span" style="font-size: large;">h</span><span class="Apple-style-span" style="font-size: large;">a</span><span class="Apple-style-span" style="font-size: large;">t</span><span class="Apple-style-span" style="font-size: large;"> </span><span class="Apple-style-span" style="font-size: large;">w</span><span class="Apple-style-span" style="font-size: large;">o</span><span class="Apple-style-span" style="font-size: large;">u</span><span class="Apple-style-span" style="font-size: large;">l</span><span class="Apple-style-span" style="font-size: large;">d</span><span class="Apple-style-span" style="font-size: large;"> </span><span class="Apple-style-span" style="font-size: large;">y</span><span class="Apple-style-span" style="font-size: large;">o</span><span class="Apple-style-span" style="font-size: large;">u</span><span class="Apple-style-span" style="font-size: large;"> </span><span class="Apple-style-span" style="font-size: large;">r</span><span class="Apple-style-span" style="font-size: large;">a</span><span class="Apple-style-span" style="font-size: large;">t</span><span class="Apple-style-span" style="font-size: large;">h</span><span class="Apple-style-span" style="font-size: large;">e</span><span class="Apple-style-span" style="font-size: large;">r</span><span class="Apple-style-span" style="font-size: large;"> </span><span class="Apple-style-span" style="font-size: large;">s</span><span class="Apple-style-span" style="font-size: large;">a</span><span class="Apple-style-span" style="font-size: large;">y</span><span class="Apple-style-span" style="font-size: large;">:</span></div><div><span class="Apple-style-span" style="font-size: large;"><br /></span></div><div>Now while this code functions, it is clearly the product of many seemingly good ideas gone horribly awry.  It is not inherently the fault of some failure in the Objective-C language that this code is so difficult to read.  Nor is it that what this code is doing is particularly difficult.  The problem is rather that along multiple steps in the design process, a failure to think occurred.  Rather than thinking about the code in a holistic fashion, focusing on the aggregate, the developers focused on minute aspects of the design without attention to unintended consequences.</div><div><br /></div><div>Let&#39;s look at a few of the problems:</div><div><ol><li>Redundant naming conventions obscure semantics.</li><li>Excessively Long Words</li><li>Inappropriate use of class inheritance.</li><li>Redundant type information.</li><li>Semantic mismatch between method and product.</li><li>Inversion of syntax against reasonable expectations.</li></ol><div><span class="Apple-style-span" style="font-size: large;">1. R</span><span class="Apple-style-span" style="font-size: large;">e</span><span class="Apple-style-span" style="font-size: large;">d</span><span class="Apple-style-span" style="font-size: large;">u</span><span class="Apple-style-span" style="font-size: large;">n</span><span class="Apple-style-span" style="font-size: large;">d</span><span class="Apple-style-span" style="font-size: large;">a</span><span class="Apple-style-span" style="font-size: large;">n</span><span class="Apple-style-span" style="font-size: large;">t</span><span class="Apple-style-span" style="font-size: large;"> </span><span class="Apple-style-span" style="font-size: large;">N</span><span class="Apple-style-span" style="font-size: large;">a</span><span class="Apple-style-span" style="font-size: large;">m</span><span class="Apple-style-span" style="font-size: large;">i</span><span class="Apple-style-span" style="font-size: large;">n</span><span class="Apple-style-span" style="font-size: large;">g</span><span class="Apple-style-span" style="font-size: large;"> </span><span class="Apple-style-span" style="font-size: large;">C</span><span class="Apple-style-span" style="font-size: large;">o</span><span class="Apple-style-span" style="font-size: large;">n</span><span class="Apple-style-span" style="font-size: large;">v</span><span class="Apple-style-span" style="font-size: large;">e</span><span class="Apple-style-span" style="font-size: large;">n</span><span class="Apple-style-span" style="font-size: large;">t</span><span class="Apple-style-span" style="font-size: large;">i</span><span class="Apple-style-span" style="font-size: large;">o</span><span class="Apple-style-span" style="font-size: large;">n</span><span class="Apple-style-span" style="font-size: large;">s</span><span class="Apple-style-span" style="font-size: large;"> </span><span class="Apple-style-span" style="font-size: large;">O</span><span class="Apple-style-span" style="font-size: large;">b</span><span class="Apple-style-span" style="font-size: large;">s</span><span class="Apple-style-span" style="font-size: large;">cure Semantics:</span></div><div><span class="Apple-style-span"  style="font-size:180%;"><span class="Apple-style-span" style="font-size: 18px;"><br /></span></span></div></div><div>When API designers require naming conventions that produce obtuse and unwieldy code, they impose a large tax upon all future development.  Looking at the two object instantiations using NSDictionary and NSNumber, you may be surprised to discover that these two class methods are both constructors.  In the old NextStep convention, a class side constructor usually repeated the name of the class as the first word in the name of a constructor.  The second part of this convention has to deal with the word <i>With</i> which serves to indicate that additional values are going to be supplied to the constructor.  </div><div><br /></div><div><span class="Apple-style-span" style="font-size: large;">2. Excessively Long Words</span></div><div><br /></div><div>When reading through the code, the words <i>kEAGLDrawablePropertyRetainedBacking, kEAGLColorFormatRGBA8, and kEAGLDrawablePropertyColorFormat</i>, all make extensive use of naming conventions which help eliminate the remotest possibility of legible code.  These words consist of 36, 21, and 32 characters each.  In comparison, antidisestablishmentarianism has only 28 characters, and is not generally considered suitable for everyday speech, excluding perhaps discussions concerning overly long words.</div><div><span class="Apple-style-span" style="font-family: monaco; font-size: 12px; "><em></em></span></div><div><span class="Apple-style-span"  style="font-size:180%;"><span class="Apple-style-span" style="font-size: 18px;"><br /></span></span></div><div><span class="Apple-style-span" style="font-size: large;">3. Inappropriate Use of Class Inheritance</span></div><div><br /></div><div>When you realize that the layer object that we are dealing with is a subclass of the layer object referenced by the object we&#39;re subclassing, most of this code makes perfect sense.  The reason that we&#39;re typecasting the object to the type we "know" it to actually be is because our use of inheritance has gone awry.  More over, our layer&#39;s particular subclass exposes a single property which is a catch all property for all of the properties we&#39;d like to set on the object.  Rather than modify actual properties of the object, we supply a dictionary containing the properties we would like to set in a slap dash fashion, and hope it all works underneath the hood.  While this may make the ABI a little more stable, it won&#39;t prevent us from attempting to set properties that don&#39;t exist, or use grossly inaccurate values.</div><div><br /></div><div><span class="Apple-style-span" style="font-size: large;">4. Redundant type information:</span></div><div><br /></div><div><div>Most of the naming conventions are redundant, especially when combined with the type information in the declarations, and the names of the parameters.  For example, if you looked up numberWithBool: in the API reference you would find the amazingly redundant:</div><div><span class="Apple-style-span" style="font-family: monaco; font-size: 12px; "><blockquote>+ (NSNumber *)numberWithBool:(BOOL)<em>value</em></blockquote></span></div></div><div>If you consider what this line actually says, you&#39;ll notice that type information is declared twice, without providing any additional information.  The icing on the cake is the choice of the word <b>value </b> to represent the value we are passing to the method.  Why not go for the hattrick and use <b>aBoolean</b> instead?</div><div><br /></div><div><span class="Apple-style-span" style="font-size: large;">5. Semantic Mismatch Between Method and Product:</span></div><div><br /></div><div>If you consider the phrasing of these constructors, they appear to be a bit awkward.  <i>numberWithBool</i> seems to imply that you can conjoining a number with a boolean, resulting in some sort of hybrid datatype, rather than deriving one from the other.  In English, we tend to indicate the genitive case using the prepositions <i>from</i> or <i>of</i> or by using an <i>&#39;s</i> not the preposition <i>with</i>.  This choice of words generates a semantic mismatch between what is said and what is actually meant.  Similarly, the phrase <i>dictionaryWithObjectsAndKeys </i>not only suffers from the same semantic mismatch, but also accepts a <i>null </i>terminated list of object, key pairs which does not naturally flow from the language.  In English, we typically introduce a list with phrases "such as the following:".</div><div><br /></div><div><span class="Apple-style-span" style="font-size: large;">6. Inversion of Syntax Against Reasonable Expectations:</span></div><div><br /></div><div><span class="Apple-style-span" style="font-size: medium;">Most programmers familiar with other languages would at first glance miss one critical piece of information regarding the design of <i>dictionaryWithObjectsAndKeys</i> and that is the argument list consists of <i>object, key</i> pairs.  In most other languages, we write associative lists using key,value pairs.  This strange inversion of convention may be a product of the implementation details, but clearly does not conform even to other common idioms in the Objective-C language.    If one were to look at a representation of dictionaries in Smalltalk, one would see a set of key -> value associations.  In the <a href="http://www.fscript.org/">F-Script</a> programming environment, NSDictionary objects can be created using the #{ key1 -> value1, key2 -> value2, ...} syntax. </span></div><div><br /></div><div><span class="Apple-style-span" style="font-size: x-large;">Final Verdict</span></div><div><span class="Apple-style-span"  style="font-size:6;"><span class="Apple-style-span" style="font-size: 24px;"><br /></span></span></div><div><span class="Apple-style-span" style="font-size: medium;">Not only is it easy to critique this code, and find plenty of fault with its formulations, it is equally easy to demonstrate several better ways of writing the exact same thing.  With a little attention to what we are trying to do, and what it is that we are trying to say, we could eliminate much of the bother from this code.  Unfortunately for us, to do this would require either writing an unreasonable amount of shim code, or going to work for Apple and redesigning some of the underlying implementation.  So for sake of argument, let&#39;s look at ways we could improve the overall design.</span></div><div><br /></div><div><span class="Apple-style-span" style="font-size: large;">Booleans are Opposites:</span></div><div><br /></div><div>Whenever you encounter a place that you are tempted to use a boolean property, it is just as easy to define two opposite methods which set the internal state of your state machine.  In our code example we use two booleans:</div><div><br /></div><div><span class="Apple-style-span" style="font-family: Monaco; color: rgb(92, 38, 153); font-size: 10px; "><blockquote><div><span class="Apple-style-span" style="font-family: Monaco; color: rgb(92, 38, 153); font-size: 10px; ">eaglLayer.<span style="color: rgb(92, 38, 153); ">opaque</span> = <span style="color: rgb(170, 13, 145); ">YES</span>;</span></div><div><span class="Apple-style-span"  style="font-size:180%;"><span class="Apple-style-span" style="font-size: 18px;"><span class="Apple-style-span" style="font-family: Monaco; font-size: 10px; "><span style="color:#000000;">[</span>NSNumber<span style="color:#000000;"> </span><span style="color:#2e0d6e;">numberWithBool</span><span style="color:#000000;">:</span><span style="color:#aa0d91;">NO</span><span style="color:#000000;">], </span>kEAGLDrawablePropertyRetainedBacking</span></span></span></div></blockquote></span></div><div><span class="Apple-style-span"  style="font-size:180%;"><span class="Apple-style-span" style="font-size: 18px;"><span class="Apple-style-span" style="font-family: Monaco; font-size: 10px; "></span></span></span></div><div><span class="Apple-style-span"   style="font-family:Monaco;font-size:85%;"><span class="Apple-style-span" style="font-size: 10px;"><br /></span></span></div><div><span class="Apple-style-span"   style="font-family:Monaco;font-size:85%;"><span class="Apple-style-span" style="font-size: 10px;"><span class="Apple-style-span" style="font-family: Georgia; font-size: 16px; ">In both of these cases, we could dramatically improve the readability of the code by introducing two separate methods:</span></span></span></div><div><blockquote><div>[ layer opaque ] vs [ layer transparent ]</div><div>[[ layer backing ] retained] vs [[ layer backing ] discarded ]</div></blockquote></div><div></div><div>Effectively, both of these idioms could be combined, if at each stage the method returned <b>self</b> rather than void or some nonsensical value.  The code could be written to say:</div><div><blockquote><div>[[[ layer opaque ] backing ] discarded ];</div></blockquote></div><div><span class="Apple-style-span" style="font-size: large;">Settings are Properties</span></div><div><br /></div><div>We could even do a similar thing with the color format of our layer, by simply adding a method to set the color format to the desired value:</div><div><blockquote>[ layer rgba8 ];</blockquote></div><div>Odds are slim that any of our color formats are going to dramatically conflict with other desirable method names.  However, if we wished to delegate the formatting behavior to a separate state machine we could simply use:</div><div><blockquote>[[ layer format ] rgba8 ];</blockquote></div><div>Regardless of how we chose to structure our data, the point is that any finite set of settings can be expressed in an equally finite number of methods.  If you have already gone to the great lengths of implementing a message passing architecture, you might as well pass the simplest messages possible.</div><div><br /></div><div><span class="Apple-style-span" style="font-size: large;">Putting It All Together:</span></div><div><br /></div><div>So what I would like to be able to say, in basically any language, would look something like:</div><div><br /></div><div><span class="Apple-tab-span" style="white-space:pre"> </span>layer rgba8 ; opaque ; backing discarded .<br /></div><div><br /></div><div>which incidentally is actually perfectly valid Smalltalk.  As such we can write the same thing in Objective-C with minor translational changes:</div><div><blockquote></blockquote><blockquote>[[[[ layer rgba8 ] opaque ] backing ] discarded ];</blockquote></div><div>If this were javascript, I could write the same functionality using the same idiom:</div><div><br /></div><div><span class="Apple-tab-span" style="white-space:pre"> </span>layer.rgba8().opaque().backing.discarded();<br /></div><div><br /></div><div>With C code, you can do exactly the same thing assuming that each returns a pointer to a structure, which contains the necessary function pointers:</div><div><blockquote>layer->rgba8()->opaque()->backing->discarded();</blockquote></div><div></div><div><blockquote></blockquote>In all four cases, in all four languages, we are equally capable of saying the exact same thing.  What these statements have in common is that they&#39;re simply a compound sentence containing a list of properties we wish the layer to have.  It is much like the English sentence where we say:</div><div><blockquote>The layer is RGBA8, opaque, and its backing store discarded.</blockquote></div><div><blockquote></blockquote>And that is beautiful code.</div><div><br /></div><div><p style="margin: 0.0px 0.0px 0.0px 0.0px; font: 10.0px Monaco"></p></div></div></div>