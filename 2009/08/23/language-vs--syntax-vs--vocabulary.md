Language vs. Syntax vs. Vocabulary
==================================

<p>The <a href="http://www.r6rs.org/steering-committee/">Scheme Steering Committee</a> recently released <a href="http://scheme-reports.org/2009/position-statement.html">a position statement</a>.  Over all, as someone who has developed commercial applications in scheme in the past, I can appreciate the reason behind this statement.  However, there are a few bits of it that stand out as symptomatic of a misconception of what and how languages should be designed.  For example:</p><br /><blockquote><br /> It is almost misleading to call Scheme a "programming language;" it would be more accurate to characterise Scheme as a family of dialects, all loosely related by the common features of lexical scope, dynamic typing, list structure, higher-order functions, proper tail-recursion, garbage collection, macros, and (some form of) s-expression based lexical syntax.<br /></blockquote><br /><p>What the authors of this statement are asserting is essentially that scheme is a language without sufficient vocabulary.  The argument is that the <a href="http://www.r6rs.org/">R6RS specification</a> does not so much define a <i>language</i> but rather the formal structure upon which a language could be built.   The problem with this statement is it is indicative of a larger problem with the perception of programming held by most programmers.  </p><br /><h3>Grammar + Syntax + Vocabular = Language</h3><br /><p><br />The meat and potatoes of the position statement is that Scheme needs more of an <i>extended vocabulary</i> such as the module systems of <a href="http://search.cpan.org">Perl</a>, <a href="http://pear.php.net/">PHP</a>, <a href="http://www.squeaksource.com/">Squeak Smalltalk</a>, <a href="http://pypi.python.org/pypi/">Python</a>, and <a href="http://rubyforge.org/">Ruby</a>.  Which have less to do with formal committee based language design, and more with the informal, ad hoc, use of the language by native speakers in their day to day activities.  Or in the words of the position statement:</p><br /><blockquote><br />More importantly, libraries or modules of code, such as URL parsers, network-protocol stacks, regular-expression implementations, and so forth, wind up stranded within the realm of a specific implementation â€“ which, in turn, means that Scheme programmers are constantly building "from scratch," rather than being able to benefit from the fruits of each others labors.</blockquote><br /><p>While building such an archive system is to be applauded, and in today&#39;s heavily networked open source community not terribly difficult, such a solution is not a panacea.  In fact, even among those languages which have long held publicly managed name spaces like Perl, huge swaths of code in the repository is often out of date, broken, incomplete, or incorrect.  As the implementation of Perl5 and Perl6 are still to this day moving targets, as well as, the myriad of "Core" CPAN modules that are often necessary to get a system running, the mere existence of a resource doesn&#39;t mean that you should use it.</p><br /><p>Now try to normalize the core language across multiple vendors, create portable code across multiple schemes, and provide a coherent vocabulary that can be used across all <i>Large Scheme</i> implementations, and you run into the same problems faced by the various Smalltalk vendors.  While the task is not insurmountable, considerable effort has been put into portability by projects like <a href="http://seaside.st/">Seaside</a> to run on the 6 platforms it supports.  Read through <a href="http://seaside.st/community/conventions">the coding conventions for the project</a> and you will quickly realize how  rather fundamental concepts such as strings and integers lack portability.</p><br /><h3>Write from Scratch</h3><br /><p>I&#39;m going to more than play devil&#39;s advocate here, and I&#39;m going to flat out advocate an opposing point of view.  <b>Write from scratch</b>.  Don&#39;t pretend that you can write portable code.  Don&#39;t convolute your language to accommodate other people&#39;s idioms.  Don&#39;t reuse other people&#39;s code when ever possible.  <b>Write from scratch</b>.</p><br /><p> Each time you work on a project, start with a blank page.  Think about what you would like to say, and how you would like to say it, and then say it.  Don&#39;t beat around the bush, pouring through mounds of inaccurate documentation, searching for a 3rd party library that will meet some of your needs, learn how to solve your actual problem yourself.  Learn how to create your solution by coming up with a hypothesis, testing it in real world settings, and revising your mental model accordingly.  <b>Prototype, test, revise!</b>  This is both how the scientific method and the design methodology work, and how we learn.</p><br /><h3>And read for gods&#39; sake</h3><br /><p>What is wrong with the steering committee&#39;s view of language is that it views language as <i>features</i>, as <i>libraries</i>, and as <i>algorithms</i>.  The statement equates the language (incorrectly I might add) with a shark (only about 2 dozen species are <a href="http://www.textbookleague.org/73shark.htm">obligate ram ventilators</a>).  A language does not need to move to live, rather it merely requires people who use it day to day.  A programming language, by the very nature of programming, largely consists of synthetic vocabulary.  We make up words and give them definitions as we go along.  A successful language makes it easy for people to add new words to the general lexicon of all those who speak the language.  It is in this respect that things like <a href="http://search.cpan.org">CPAN</a> have been phenomenally successful, and not because there is a plethora of high quality libraries.  (The quality of most modules is actually quite low). </p><br /><p>More importantly, the ease with which new programmers can <b>read</b> other programmer&#39;s source code, directly influences how successful a language becomes.  Compare the rise of <a href="http://python.org">Python</a> and Javascript over languages like Smalltalk.  Smalltalk has simpler syntax, is generally written such that English speakers can understand the code, but yet a language like Python can eclipse it in terms of <a href="http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html">popularity</a>, why?  The reason is that its syntax is more similar to the other popular languages.  Java, C, C++, PHP, Python, C#, Perl, Javascript, and Ruby all share a common heritage when it comes to syntax.  All these languages are members of the ALGOL family.    More over, the style of ALGOL has influenced the style of the description of algorithms in textbooks and academic papers.  Even the BNFs we use to describe the syntax of most languages, were derived to describe ALGOL.  Since we teach kids in school this style, it is <i>familiar</i>.  We then teach them these languages in this <i>familiar</i> style, these languages then become <i>popular</i>.  Even though this <i>familiar</i> style is totally alien to every other human language we use in every day life.</p><br /><p>So if you&#39;re <b>writing from scratch</b>, why should you read other people&#39;s programs?  Because that&#39;s the quickest way to learn how things work.  Being able to read is a prerequisite to learn something written in a language.  Learning to read scheme is actually the greatest barrier to new programmers mastering the language.  Because it&#39;s syntax is unfamiliar, due to not matching the normative syntax of algebra taught in schools, it requires a high degree of retaining and reading large amounts of scheme code to learn the language.  Not only must you learn what the program does, you must also learn how to read the syntax of the program.  As such no amount of new vocabulary will make it any more popular.  In fact, adding new unfamiliar vocabulary to an already alien language will do little to breed new interest in scheme.<p><br /><h3>The problem with languages like Klingon, is they don&#39;t have enough words.</h3><br /><p>In my view, the Scheme Steering Committee is basically making the argument that "Klingon would be more popular if only it had more words."  The goal of <i>Large Scheme</i> to add more standard vocabulary to the language is exactly the same as the proposition to add words to the Klingon language.  In reality, the only way Klingon would become more popular is if:</p><br /><ul><br /><li>There was a sudden uptick in the number of Klingons to speak to.</li><br /><li>We started teaching kids Klingon as a second language in schools.</li><br /><li>People could make money speaking Klingon to other Klingon speakers.</li><br /></ul><br /><p>So short of NASA actually discovering actual real live Klingons out in space, we&#39;re probably only going to see an uptick in Klingon popularity if there were a government sponsored KSL mandate, and someone opened a Klingon-only Star Trek theme park.  This is the same reality that <i>marginal</i> languages like Scheme, like Forth, and like Smalltalk, will always find themselves facing.  There will never be a sufficiently high performance or economic incentive great enough to sway people from languages that are more <i>familiar</i>, due to the <i>synthetic familiarity</i> of having learned it as kids in school.  Once you&#39;ve trained a kid to read one language, all others tend to become <i>hard to read</i>, not because they actually <b>are</b> harder, but because subjectively they <b>seem</b> harder.</p>