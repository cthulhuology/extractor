A short word on Forth
=====================

The past few nights, I have been consistently working on Forth projects. I&#39;m in the process of writing a websocket client/server implementation in forth, aiming for portability (32bit micros right now only though), and finding it amazingly regressing.  In one night, I wrote a merseene twister prng, and it worked nicely after about 3 hours.  That is I want from reading the paper, reading a C implementation, to having a functional implementation in 3 hours. I tried to do the same thing for sha1 the next night, and tried to cheat by porting a C implementation before realizing the C port had a horrid endk an bug that would be terrible to unravel. That&#39;s what I get for reading SSLeay code!  So the following night I went back to the NIST document itself, and implemented SHA1 from scratch. It will take a few mor hours to get multiple blocks hashing, but that is due to need for writing the test cases for all the padding variants.  My next project will be to do base64 encode/decode, and that should take a few hours. I plan on 2 more days based on this progress to do the websocket framing, but I&#39;ve done websocket implementations in other languages before, so I can skip rereading the spec again.<br><br>What amazes me about the solutions I&#39;m creating is I am consistently writing about 100 lines of tested code in 3 hours. That is about 33 lines per hour, or better than half a tested line of code per minute!  And since this is forth, there can be quite a few operators on a single line, far more functionality than in a single line if C.  As I&#39;m squeezing out 3-10 lines of C equivalent per minute, I&#39;m looking at 1.5-5 LoCC per minute. I can&#39;t pretend to be able to write and test at that rate. Just the build cycle alone kills that productivity. With an image based forth, I need not even leave the test environment, it is always running, always available, and always active. My compilation on some forths happens entirely between keystrokes as I type. This should be normal.<br><br>Truly interactive development emvironments, like Forth, Smalltalk, Self, are all far more productive in my personal experience.  I&#39;ve been amazed at my own ability to just implement from scratch solutions to "hard problems". Now that I have this code, I never need to implement it again.  Forth is so portable, I can port this code to nearly any architecture, and because I wrote comments for myself, I know which bits I need to alter to support other platforms.  Some  time next week, I should have a fully functional modern web development platform in Forth. I&#39;m also now thinking of writing database interfaces, message queue protocol interfaces, and low level hardware drivers in Forth.  Piece by piece, I&#39;ve been removing my barriers that pvsnted me from using the language in the past.  And now that. I can burn most of these problems in a  night&#39;s hacking.  I&#39;m running out of excusesses.  