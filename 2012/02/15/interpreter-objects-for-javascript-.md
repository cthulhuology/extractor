Interpreter Objects for JavaScript 
===================================

For the past few weeks, I have been playing around with a JavaScript object that interprets its arguments when invoked as a function in its own context.Â <br><br>Â  Test("log:","hello Dave, 1 + 2 =", 1,2,"+", "log")<br><br>Where in:<br><br>Function.prototype["+"] = function() {Â <br>Â  Â  Â  Â  this[&#39;.stack&#39;].push(this[&#39;.stack&#39;].pop() + this[&#39;.stack&#39;].pop());<br>Â  Â  Â  Â  return 0 }<br><br>Function.prototype[&#39;log:&#39;] = function(x) {<br>Â  Â  Â  Â  this.globals.console.log(x);<br>Â  Â  Â  Â  return 1 }<br><br>Function.prototype.log = function() {<br>Â  Â  Â  Â  this.globals.console.log(this[&#39;.stack&#39;].pop());<br>Â  Â  Â  Â  return 0 }<br><br>How it works is each word is either a method of the object or a global reference (hoisted via a globals proxy) or a literal value. Any literal value is simply any non-method named argument pushed onto the object&#39;s stack and treated as data. Â The definition of the Function object has much to do with using multiple instances of the same interpreter function as our base object. Â In effect, we attach the state machine onto the new Function() we construct for each "Object" in the system and let it maintain its locality. Â  "Objects" in this system interact by passing messages via a simple JavaScript function call. Any object with a reference to another object can invoke its methods by simply calling that object-function passing the messages as arguments.Â <br><br>Part of the programming model for this environment is that strings can contain source code which can be compiled and evaled as well. The way it works is that String.prototype is extended with a .compile and .eval method so that one can say:<br><br>Â Foo.alert = Â &#39;alert("hello world")&#39;.compile()<br><br>which would be the equivalent of:<br><br>Â  Foo.alert = function() {Â <br>Â  Â  Â  Â  Â  alert("hello world");Â <br>Â  Â  Â  Â  Â  return; }<br><br>For parameter definitions, you can use the | separator to separate a list of params from the body of the function:<br><br>Â  Foo.alert = &#39;name | alert("hello " + name)&#39;.compile()<br><br>This is the equivalent of:<br><br>Â  Foo.alert = function(name) {<br>Â  Â  Â  Â  Â  alert("hello " + name);Â <br>Â  Â  Â  Â  Â  return 0; }<br><br>In this fashion one can add as many params as one wants and it will generate the associated function. Â Another fun feature is using the innerText property of a DOM element to inline your code:<br><br>Â  document.querySelectorAll(".code").map(&#39;x | Â x.innerText.eval()&#39;.compile())<br><br>This will take each element on a page with class code and evaluate it as if it were scripted using these tools. We&#39;re using Â compile() to return the function, and using eval to run the embedded code. Â This trick is lots of fun for syntax highlighted code listings that are also executed on the page. Â  We can use all of this together with CSS to produce executable documents with many embedded stack machines. Â  We can also embed and send objects via JSON to other machines with the ability to embed context:<br><br>[ &#39;Foo&#39;, &#39;does:&#39;, &#39;alert:&#39;,&#39;name | alert("hello " + name)&#39;]<br><br>Where the recipient of the JSON constructs a &#39;Foo&#39; object in its current context, applies the &#39;does:&#39; method of Foo, which compiles the method named &#39;alert:&#39;, which itself a method of Foo defined as:<br><br>Â  function(name) {<br>Â  Â  Â  Â  alert("hello " + name);<br>Â  Â  Â  Â  return 1 }<br><br>What is interesting here is &#39;alert:&#39; itself derives the value of name from the message stream and not the object&#39;s internal state.Â <br><br>Â  Foo(&#39;alert:&#39;,&#39;Dave&#39;);<br><br>Will in fact pop up "hello Dave" as the return 1 indicates that &#39;alert:&#39; is a message parsing method with arity 1. In the case of:<br><br>Â  Â Foo(1,2,&#39;+&#39;)<br><br>The messages 1, 2, and &#39;+&#39; are all methods of arity 0. The compile method on string has the nice property of returning the arity as the return value. Each method by the conventions of the compiler requires the method return the number of parameters a message expects so it can consume that many from the message stream.Â <br><br>Take for example a method like &#39;does:&#39;, which takes 2 arguments and generates a method definition. Â The underlying method looks something like:<br><br>Â  Â function(name,method) {<br>Â  Â  Â  Â  Â  this[name] = method.compile();<br>Â  Â  Â  Â  Â  return 2 }<br><br>That is pretty much it, you can rewrite &#39;does:&#39; as a 2 stage process:<br><br>Foo(&#39;define:&#39;, &#39;alert&#39;,&#39;as:&#39;, &#39;| alert("goodbye")&#39;)<br><br>Which would look something like:<br><br>Foo(&#39;does:&#39;,&#39;define:&#39;, &#39;term | this[".term"] = term&#39;)<br>Â  Â  Â  Â  (&#39;does:&#39;,&#39;as:&#39;,<br>Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  &#39;method| this[this[".term"]] = method.compile()&#39;)<br><br>And now we have two unary messages in the place of one through an addition to the statemachine. Â We can push this further:<br><br>Â  Foo(&#39;define:&#39;,&#39;define&#39;,&#39;as:&#39;,<br>Â  Â  Â  Â  Â  &#39;| this[".term"] = this.stack.pop()&#39;)<br>Â  Â  Â  Â  Â  (&#39;as&#39;,&#39;define&#39;,&#39;as:&#39;,<br>Â  Â  Â  Â  Â  Â  Â  Â  Â  &#39;| this[this[".term"]] = this.stack.pop().compile()&#39;)<br><br>We now have two null arity methods which take their arguments on the internal stack. This exploits any string which is not a method is a literal:<br><br>Â  Foo(&#39;warn&#39;,&#39;define&#39;, &#39;| console.warn(this.stack.pop())&#39;,&#39;as&#39;)<br><br>This being better than that is a mere point of debate, but this pretty effectively illustrates how flexible this approach can be. Â In fact, we can take a hybrid approach and define does as:<br><br>Â  method | this[this.stack.pop()] = method.compile()<br><br>so it would look like:<br><br>Â  Foo(&#39;warn&#39;,&#39;does:&#39;,&#39;| console.warn(this.stack.pop())&#39;)<br><br>Which opens up the possibility of using a method to generate a method name, and leave it on the stack.Â <br><br>This code will be up on my github shortly...