Beautiful Code and Idiosyncratic Programming
============================================

Recently I showed a friend some code that looked like this:<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/_XCDTVvEbBMU/TUy2UfN28zI/AAAAAAAAAFs/ufgiV49Jh-4/s1600/Screen%2Bshot%2B2011-02-04%2Bat%2B9.29.43%2BPM.png"><img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 400px; height: 46px;" src="http://2.bp.blogspot.com/_XCDTVvEbBMU/TUy2UfN28zI/AAAAAAAAAFs/ufgiV49Jh-4/s400/Screen%2Bshot%2B2011-02-04%2Bat%2B9.29.43%2BPM.png" border="0" alt=""id="BLOGGER_PHOTO_ID_5570027302243726130" /></a><br /><br />When executed it does:<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://1.bp.blogspot.com/_XCDTVvEbBMU/TUy2h7UX65I/AAAAAAAAAF0/WXm6uNuFDJk/s1600/Screen%2Bshot%2B2011-02-04%2Bat%2B9.29.51%2BPM.png"><img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 400px; height: 145px;" src="http://1.bp.blogspot.com/_XCDTVvEbBMU/TUy2h7UX65I/AAAAAAAAAF0/WXm6uNuFDJk/s400/Screen%2Bshot%2B2011-02-04%2Bat%2B9.29.51%2BPM.png" border="0" alt=""id="BLOGGER_PHOTO_ID_5570027533125544850" /></a><br /><br />And then:<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://3.bp.blogspot.com/_XCDTVvEbBMU/TUy2qLeYptI/AAAAAAAAAF8/aRv2VdLRm2M/s1600/Screen%2Bshot%2B2011-02-04%2Bat%2B9.29.57%2BPM.png"><img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 400px; height: 144px;" src="http://3.bp.blogspot.com/_XCDTVvEbBMU/TUy2qLeYptI/AAAAAAAAAF8/aRv2VdLRm2M/s400/Screen%2Bshot%2B2011-02-04%2Bat%2B9.29.57%2BPM.png" border="0" alt=""id="BLOGGER_PHOTO_ID_5570027674901456594" /></a><br /><br />This example displays how a String that looks like a URL can work like a URL.  It also shows how we can asynchronously define a callback for an asynchronous fetch.  It also demonstrates how we can chain callbacks to define a progression of states.  It all starts with a very simple bit of code:<br /><br /><pre><br />String.prototype.get = function(cb,data) { return this.request("GET") }<br /></pre><br /><br />Which invokes a slightly more complex bit of code, that does a XHR fetch<br /><br /><pre><br />String.prototype.request = function(method,data) {<br />        var _request = XMLHttpRequest ? new XMLHttpRequest(): _doc.createRequest();<br />        var cb = function () {<br />                if (this.readyState != 4) return;<br />                if (this.status == 404) cb.process(null);<br />                if (this.status == 200) cb.process(this.responseText);<br />        };<br />        _request.onreadystatechange =  cb;<br />        _request.open(method,this,true);<br />        _request.setRequestHeader(&#39;Content-Type&#39;,&#39;text/plain&#39;);<br />        _request.send(data ? data : &#39;&#39;);<br />        return cb;<br />}<br /></pre><br /><br />The key bit here is that the closure invokes <b>cb.process()</b> and returns the callback as the final operation.  The way that the process method works:<br /><br /><pre><br />Function.prototype.process = function() {<br />        if (typeof(this.Pending) == "function") <br />                this.Pending.apply(this.Pending,arguments);<br />}<br /></pre><br /><br />Which simply calls the "Pending" property of the callback function, which holds the chain of callbacks.  We set this property in the original bit using the <b>then()</b> function:<br /><br /><pre><br />Function.prototype.then = function(f) { <br />        var me = this;<br />        this.Pending = function() { <br />                var results = f.apply(f, arguments); <br />                if (!results) results = [];<br />                f.process(results);<br />        }<br />        return f;<br />}       <br /></pre><br /><br />where in we wrap the callback we&#39;re passed in another function which knows how to apply it to whatever arguments we pass to it via <b>process()</b>.  For the chain, we pass the results of each function as the arguments to the next, allowing us to perform a sequence of transformations and share state.  <br /><br />This technique also works beautifully for adding timer callbacks for generating asynchronous processing using the setTimeout interface.  In this way we can declare behavior in a straight forward manner.