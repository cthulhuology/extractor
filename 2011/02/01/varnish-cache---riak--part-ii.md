Varnish Cache + Riak: Part II
=============================

A few days ago, I wrote up how to implement a simple <a href="http://varnish-cache.org/">Varnish cache</a>   <a href="http://basho.com/riaksearch.html">Riak key value store</a> setup for development use.  Not only did I use Varnish as a cache, but I also used it to rewrite request paths to point different paths to different buckets.  I also added some basic access control, using the acl feature to restrict access to the /admin/ interfaces.<br /><br />Today, I&#39;m going to address the question:<br /><br /> "How does this setup account for inconsistencies between multiple varnish nodes after requests that cause a purge?"<br /><br />Sort answer is the development server where you&#39;re running varnish on one box on port 80, and riak running on 3 ports on the same box does not.  It assumes that you are going through a single varnish node in development.  When you go to production, however, this is not only unadvisable but also highly unlikely.  Managing cache state across multiple varnish caches requires that you execute the <i>purge.url</i> directive on all of the nodes that have access to that resource on the backend.<br /><br />There are three basic approaches you can take:<br /><br /><ol><br /><li>Have a service monitor PUT, POST, DELETE requests from the Varnish logs and propagate the changes</li><br /><li>Add hooks to Riak to relay the purge requests to each varnish node upon successful update</li><br /><li>Have varnish relay the request to its peers</li><br /></ol><br /><br />For the purposes of this article, I&#39;m going to focus on #3, and demonstrate how you can embed C code in your .vcl file to invoke arbitrary web requests to other servers within varnish.  But first a disclaimer: <b>NB: I do not recommend you do this, and don&#39;t blame me when you DDOS your own site!</b>.<br /><br />Ok, that out of the way, Varnish requires GCC be installed on your production boxes.  The reason Varnish requires this is that it actually compiles your .vcl file into a shared library and loads it via dlopen.  It then uses the sub routine hooks to extend the functionality of the server at run time via native code.    This is why .vcl files can have C{ }C directives embedded inside of them, which compile down to native code, and perform their tasks as quickly as anything that can be done on your server.<br /><br />In our previous example, we were already catching the PUT, POST, and DELETE  http methods as follows:<br /><br /><pre><br />         if (req.request == "PUT" || req.request == "DELETE" || req.request == "POST")  {<br />                purge("req.url ~ " req.url);<br />                return(pass);<br />        }<br /></pre><br /><br />This was done to purge the cache before passing through to the backend Riak servers to process the PUT, DELETE, or POST.  So if we are going to support a number of other varnish nodes in our cluster, we probably want to propagate the purging to all of the nodes in the cluster.  So that the next time the client requests the newly written data, and hits a different box, they will not be fed a stale piece out of cache.  To do this we can change the config to read as follows:<br /><br /><pre><br />        if (req.request == "PUT" || req.request == "DELETE" || req.request == "POST")  {<br />                set req.http.X-Purge-Path = req.url;<br />                C{<br />                        purge_remotes(VRT_GetHdr(sp,HDR_REQ,"\\015X-Purge-Path:"));<br />                }C<br />                purge("req.url ~ " req.url);<br />                return(pass);<br />        }<br /></pre><br /><br />Here we are appending a new header entry, "X-Purge-Path:" to our request header, which will be passed on to Riak, as well, which we then use to call a native C function <b>purge_remotes</b>.  We then purge the local cache and pass it on through to Riak.  To implement purge_remotes we will embed some more C at the beginning of the file:<br /><br /><pre><br />C{<br />#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br />#include &lt;dlfcn.h&gt;<br />#include &lt;syslog.h&gtl<br />#include &lt;curl/curl.h&gt;<br />}C<br /></pre><br /><br />Doing this will provide access to syslog, dlopen, dlsym, and curl.  In order to purge the remotes, we will use libcurl to make PURGE requests to the peers, and allow each of them to clear their caches.  To setup that bit, we can expose the peer configuration as a C string array and include the source file for our purge_remotes function:<br /><br /><pre><br />C{<br />char* peers[] = { "localhost:8008", NULL };<br />#include "/Users/dave/Servers/purge_remotes.c"<br />}C<br /></pre><br /><br />For this example, we&#39;re only going to run one peer running on a different port on the same machine, but you can easily add any number of machines to the lists of peers.  The trailing NULL is important, as we are going to make one PURGE request for each string in this array, until we encounter a null pointer value.  The second line simply includes the C source file directly into our VCL which is then compiled inline.  This allows us to save the bulk of our C code in an external file and edit it independently.<br /><br />The final bit of configuration change we need for this to work is to add the handler for our PURGE method, so that if one of our peers contacts us about an update they did, we can handle it gracefully:<br /><br /><pre><br />        if (req.request == "PURGE" ) {<br />                purge("req.url ~ " req.url);<br />                error 200 "OK";<br />        }<br /></pre><br /><br />This is all one needs to handle the PURGE request, and since we don&#39;t really care that much about the response, we&#39;re just going to error out with a 200 OK.  You could go to some length to minimize the payload here, and you could synthesize a response, but for now this will be sufficient to demonstrate the technique.<br /><br />The implementation of <b>void purge_remotes(char* path)</b> is fairly straight forward and consists of 3 general parts, a preamble, an initialization section, and the request dispatch.  The preamble is trivial:<br /><br /><pre><br />void purge_remotes(char* path) {<br />  CURL *curl;<br />  CURLcode res;<br />  int i;<br />  char* url = NULL;<br /></pre><br /><br />Here we declare the function prototype and the local variables.  The path is passed to us from the embedded C code in vcl_recv.   After this we need to dynamically load the functions from libcurl into our current process space, and lookup each of the symbols that we will need to use the Curl API:<br /><br /><pre><br />  void* libcurl = dlopen("/opt/local/lib/libcurl.dylib", RTLD_LAZY|RTLD_LOCAL);<br />  if (!libcurl) {<br />        syslog(LOG_ERR,"Could not open libcurl");<br />        return;<br />  }<br /><br />  CURLcode (*curl_easy_setopt_p)() = dlsym(libcurl,"curl_easy_setopt");<br />  CURLcode (*curl_easy_perform_p)() = dlsym(libcurl,"curl_easy_perform");<br />  CURL* (*curl_easy_init_p)() = dlsym(libcurl,"curl_easy_init");<br />  void (*curl_easy_cleanup_p)() =dlsym(libcurl,"curl_easy_cleanup");<br />  if (! curl_easy_setopt_p || ! curl_easy_perform_p || ! curl_easy_init_p || ! curl_easy_cleanup_p) {<br />        syslog(LOG_ERR, "Could not find symbol for some curl function");<br />        return;<br />  }<br /></pre><br /><br />Dlopen takes a path, and a set of flags which in this case tell it to open my copy of libcurl from MacPorts, and set it to lazy load the symbol references and to not export any symbols into the processes global symbol table.  This is the safest option from a linking standpoint, as dlopen will automatically handle not loading the library more than once, and only our code will have access to the function pointers.  The following lines then load: curl_easy_setopt, curl_easy_perform, curl_easy_init, and curl_easy_cleanup.  The function pointers (all ending in _p) allow us to call those shared library functions.  If any of these pointers fail to be found, or the library fails to load, we quit out and don&#39;t proceed with processing the purge.<br /><br />The final bit is the bit that actually performs the remote purge requests:<br /><pre><br />  curl = curl_easy_init_p();<br />  if(curl) {<br />    for (i = 0; peers[i];   i) {<br />      asprintf(&url,"http://%s%s",peers[i],path);<br />      curl_easy_setopt_p(curl, CURLOPT_CUSTOMREQUEST, "PURGE");<br />      curl_easy_setopt_p(curl, CURLOPT_URL, url);<br />      res = curl_easy_perform_p(curl);<br />        syslog(LOG_INFO,"Purged %s",url);<br />      free(url);<br />      url = NULL;<br />    } <br />    curl_easy_cleanup_p(curl); <br />  } <br /></pre><br /><br />All that we do is init curl, create a new request for each peer in peers, with the appropriate path.  We then modify the method using the CURLOPT_CUSTOMREQUEST field, and perform the request.  Finally we clean up after ourselves, and free all of the memory we allocated for this process.  And we&#39;re done!  If you then ran 2 varnishes on different ports, and had the same config for each you can test this by using curl to put a new index.html page in your site bucket:<br /><br /><pre><br />curl -X PUT http://localhost/riak/site/index.html -H "Content-type: text/html" --data-binary @Sites/index.html<br /></pre><br /><br />You can also use curl to purge your caches by hand by doing things like:<br /><br /><pre><br /> curl -X PURGE http://localhost/<br /></pre><br /><br />Which varnish will map to the appropriate backend asset and purge its cache internally.  <br /><br />In this example configuration, there is a sever performance bottleneck.  In order to make it easy to understand, I used the <b>easy</b> curl interface.  This blocks each request before continuing onto the next one.  This means that all of the remote caches will be purged prior to the contents being updated.   Not only does this introduce a new race condition, but it also doesn&#39;t scale very well.  However that said, using the <a href="http://curl.haxx.se/libcurl/c/libcurl-multi.html">curl multi interface</a> for full asynchronous purging is also possible.  The application of that is almost identical, but presents interesting challenges when debugging across multiple machines.<br /><br />Once again, if you have a resource that has a high write volume, you are probably better off not caching it at all, and instead making those a straight pass through to Riak.  Riak tends to perform as well as varnish in serving most static files.  But for resources that are expensive like map-reduce queries or full key listings, having a cache in front can make your life much easier.<br /><br />Stay tuned for more.