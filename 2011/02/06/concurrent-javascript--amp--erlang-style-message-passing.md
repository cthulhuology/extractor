Concurrent Javascript &amp; Erlang style message passing
========================================================

Today I added a few nice additions to the latest version of Phos.  Since I&#39;ve been writing a lot of Erlang the past few weeks on another related project, I decided that I should add the equivalent of Erlang processes to the Phos object set.  The result of about an hour of hacking is a fully functional process system for pseudo-concurrent processing in Javascript.   The first function that I implemented was <b>spawn</b> which creates a new process to which we can attach behavior:<br /><pre><br />Function.prototype.spawn = function() {<br />        var fun = function() {<br />                if (fun.caller != null) return fun.send.apply(fun,arguments);<br />                if (fun.Mailbox.length) {<br />                        var message = fun.Mailbox.shift();<br />                        var op = message.shift();<br />                        if (typeof(fun[op]) == "function")<br />                                return fun[op].apply(fun,message);<br />                        else fun["_"].apply(fun,[ op, message]);<br />                }<br />        };<br />        fun.Mailbox = [];<br />        return fun.start();<br />};<br /></pre><br />In this case, <b>spawn</b> creates a new function which has a <i>Mailbox</i>, a dispatch lookup, and a default message handler <b>_</b>.  The default message handler is inspired by Smaltalk&#39;s <b>doesNotUnderstand</b> method, and by default simply logs a message to the console saying that the function doesn&#39;t understand the message:<br /><pre><br />Function.prototype._ = function(op) {<br />        console.log(this.name + " does not understand " +  op);<br />}<br /></pre><br />The functions generated by <b>spawn</b> have 2 different modes of operation.  The primary mode is as the API to the process, which sends a message to the mail box.  For example, if we spawn a function called <b>foo</b>, we can send it a message by invoking it as follows:<br /><pre><br />var foo = Function.spawn();<br />foo("alert","this is a test");<br /></pre><br />Since we have not attached a behavior to foo to process alerts this will result in the following output in the console:<br /><pre><br />foo(&#39;alert&#39;,&#39;this is a test&#39;)<br />function () { <br />  if (fun.caller != null) return fun.send.apply(fun,arguments);<br />  if (fun.Mailbox.length) {<br />   var message = fun.Mailbox.shift();<br />   var op = message.shift();<br />   if (typeof(fun[op]) == "function")<br />    return fun[op].apply(fun,message);<br />   else fun["_"].apply(fun,[ op, message]);<br />  }<br /> }<br />Function:57 does not understand alert<br /></pre><br />But if we then attach some behavior to the <b>foo.alert</b> method of the function we can fire off an alert:<br /><pre><br />foo.does(&#39;alert&#39;, function(x)  { alert(x) });<br />foo(&#39;alert&#39;,&#39;this is a test&#39;);<br /></pre><br />Which will then pop open a new alert with the message "this is a test".<br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/_XCDTVvEbBMU/TU9eFrriiLI/AAAAAAAAAGE/TKfhxwKkshY/s1600/Screen%2Bshot%2B2011-02-06%2Bat%2B9.50.18%2BPM.png"><img style="float:right; margin:0 0 10px 10px;cursor:pointer; cursor:hand;width: 400px; height: 148px;" src="http://2.bp.blogspot.com/_XCDTVvEbBMU/TU9eFrriiLI/AAAAAAAAAGE/TKfhxwKkshY/s400/Screen%2Bshot%2B2011-02-06%2Bat%2B9.50.18%2BPM.png" border="0" alt=""id="BLOGGER_PHOTO_ID_5570774715798292658" /></a><br />By default, <b>spawn</b> fires off an interval timer for each function that is spawned.<br /><pre><br />Function.prototype.start = function() {<br />        var fun = this;<br />        if (fun.Pid) return;<br />        this.Pid = setInterval( fun, fun.Delay );<br />        return this;<br />}<br /><br />Function.prototype.stop = function() {<br />        clearInterval(this.Pid);<br />        this.Pid = false;<br />        return this;<br />}<br /></pre>  This interval timer has a delay that can be set as a value in milliseconds.  Passing in a value of 0, effectively makes the function burn CPU, and is generally not recommended.  The delay works as a sort of priority rating, allowing you to create different tiers of responsiveness.  To change a function&#39;s delay property, you must first <b>stop</b> the process which will cancel its interval timer, and then <b>start</b> it again with the new delay.<br /><pre><br />Function.prototype.delay = function() {<br />        if (arguments.length) {<br />                this.Delay = arguments[0];<br />                return this;<br />        }<br />        return this.delay;<br />}<br /></pre><br />Because each function processes its messages in the order that they were received, each function defines its own job queue.  Additionally, since each function can contain its own state properties, it is possible to maintain a finite state machine within the function itself.  Also, since multiple function properties can be associated with each function, on process can respond to many different messages.  The messaging protocol is rather simple:<br /><pre><br />myFunction( &#39;message&#39;, arguments ... )<br /></pre><br />Since the first parameter is the name of the method you wish to invoke, you can name each transition in your state machine and invoke them via message send.  The function itself is always passed along as the object on which the method is applied, so its full state is also available via <b>this</b> in the method&#39;s context.  It is trivial to pass along complex representation of state in additional properties of the function.  Currently only <i>Mailbox</i>,<i>Pid</i>,<i>Delay</i>, and <i>Pending</i> are used to store state information in the mechanisms used by this module.  Pending is used to create a chain of continuations using the then() wrapper, which isn&#39;t necessary if you use full function processes and message passing.<br /><h3>Sample Application</h3><br /><pre><br />chatLog = A.function().<br />        does(&#39;draw&#39;, function(x) { The.Screen.print(x).print("\\n") }).<br />        does(&#39;clear&#39;, function() { The.Screen.clear() }).<br />        does(&#39;sync&#39;, function() { "http://chat.dloh.org".get().<br />                then(function(messages) { chatLog(&#39;clear&#39;); messages.each(function (x) { chatLog(&#39;draw&#39;,x) })<br />        })<br /></pre><br />So why would you want such a thing?  Well look at the sample chat log widget in the listing above.  It is effectively a message server that has 3 base operations: <i>draw</i>,<i>clear</i>, and <i>sync</i>. Each operation can be invoked by any 3rd party process, but each is performed primarily as a result of an asynchronous HTTP fetch via XHR.  We could have also written it as follows:<br /><pre><br />chatLog = A.function().<br />        does(&#39;draw&#39;, function(x) { The.Screen.print(x).print("\\n") }).<br />        does(&#39;clear&#39;, function() { The.Screen.clear() }).<br />        does(&#39;sync&#39;, function() { "http://chat.dloh.org".get().<br />                then(function(messages) { chatLog.clear(); messages.each(function (x) { chatLog.draw(x) })<br />        })<br /></pre><br />And it will have the same observable effect, but in a fully synchronous fashion but using only the XHR thread!  This might not seem important, until you consider what happens when there are more than one object writing to that chatLog.<br /><pre><br />chatEditor = A.function().<br />       does(&#39;post&#39;, function(x) { chatLog(&#39;draw&#39;,x); chatServer(&#39;send&#39;,x).then(&#39;sync&#39;) }).<br /></pre><br />In this case, we want to show the user that we&#39;ve posted our message, by appending it directly to the chat log, and then we post it to the server.  Only after the chat server has acknowledged our post, do we then request the chatServer apply its sync method, which will then redisplay the chat with our message and the other new messages in the correct order.  This allows us to be more responsive to the user&#39;s actions, and have multiple concurrent processes communicate between each other better encapsulating the behaviors.  It also allows us to defer action until a time slice becomes available for a given subsystem, and not block all processing in particularly heavy activities.<br /><br />This all become much more useful as well when you attach multiple nested contexts into a page, and use things like &lt;iframe&gt; and &lt;object&gt; tags to embed content.  Using HTML5 cross document messaging with a Publisher/Subscriber model messaging hub in conjunction with message passing process functions dramatically simplifies the programming model as both local and remote messages are all processed asynchronously.  When user driven events, timers, network events, and cross document messages are all in play, having a unified model become essential.<br /><br />Looking at the direction of Phos in the near future, I am almost certain that all of the core subsystems will be re-implemented using this model.  It will make the rendering pipeline simpler.  It will make event dispatching cleaner as well.  Finally, it will in conjunction with the PubSubHub module, make it possible to build the <b>Web Widgets Platform</b> in a way that will be reusable across nearly all existing web sites.  Finally, it dovetails nicely with the backend work I&#39;ve been doing in Erlang, and will provide the sort of fault tolerance currently missing from the single-threaded Phos.