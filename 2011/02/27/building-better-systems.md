Building Better Systems
=======================

There is a preponderance of evidence that supports the conjecture that "most software sucks". <br /><br />Reasonable programmers working in industry know this. The reasons for it have largely nothing to do with computers, the tools used, or the design of the system. The primary reasons have nothing to do with development methodology, choice of technology, or which editor you choose. None of the religious wars that rage among technologists even hint at the true problem. <br /><br />The problem of software sucking is a political problem. And if man is a political animal, then software sucking is tantramoumt to a direct manisfestation of human nature. To understand this, think about the problem of local state vs. global state. There is a current culture that holds global state is bad, and that it is better to pass a pointer to a global data structure around on the stack for all functions. We then need optimizing compilers that will cleverly store that value in a register due to SSA. All of which has absolutely nothing to do with the capabilities of the computer. <br /><br />The computer doesn&#39;t know the difference between local and global state. You give it a memory address and it will translate it to some collection of wires from which it will pull current to store the next value in a register. It the address is indirect via a stack pointer or indirect via a page descriptor it doesn&#39;t make a difference to it. The computer imparts no special significance to either. In fact it imparts no meaning to anything at all. <br /><br />The significance lies only in the mind of the programmer. Things likes global vs local are crutches designed to help programmers with limited capacity to reason about billions of numbers, let alone concieve of them, do something useful with them. By compartmentalizing our mental model, we can break the problem space down into parts small enough to fit inside our heads. <br /><br />This same behavior which makes programming large systems possible also creates the political problems that makes software suck. In days gone by when many programs were the product of a single programmer the resulting program need only fit inside one head. As a result, that one head could exploit this fact and desiggn for the computer, making the machine perform closer to it&#39;s potential. <br /><br />As time went on and software became ubiquitous, teams of programmers became necessary to do anything. The proliferation of programming languages, techniques, and ideologies that followed were largely driven by the political problem of how to organize programmers to do useful work. <br /><br />Java is a perfect example of this process in action. As languages go, Java is minimally expressive, with a vast irregular vocabulary, and requires an inordinate amount of structure to perform even trivial tasks.  What it does well however is prevent the sort of clever programming which will make an average programmer&#39;s head spin. <br /><br />A language like Java makes software suck not because it must, or even because Java lacks the features necessary for not sucking. Java makes it suck because the political thought behind the language is in active opposition to beauty and efficiency. It is born out of a desire to reduce risk by turning programming from a craft to an industrial exercise in assembly line programming