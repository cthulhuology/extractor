A Scheme for Messaging
======================

The past couple weeks I have been actively using a messaging framework for sharing information between both nested contexts (iframes, object tags) and backend services (via XHR and websockets). By defining the simplest protocol that would work in all contexts:<br><br>  S-expression<br><br>And choosing an encoding that is well supported on the web:<br><br>  JSON<br><br>We get a powerful force for making web apps look like Erlang nodes!<br><br>  [ &#39;subject&#39;, &#39;verb&#39;, predicate objects ... ]<br><br>This pattern has been common across many different languages and is influenced largely by English sentence structures.   The key observations to make here:<ul><li>subject may refer to 0 or more objects, (think collective nouns)</li><li>verb is just a method that any subject may or may not implement</li><li>predicate objects MUST be self referential, as in they must carry their own representation</li></ul><br>If you&#39;ve been following my Self.js work, you&#39;ll realize that this last constraint means that if one can represent code as data as an s-expression, one can ship arbitrary code to any node in the predicate objects provided that the recipient platform enables those transformations. <br><br>The obvious way of translating the message to an actual invocation is (in Coffeescript)<br><br>  Actors[ subject ]?[verb]?.apply(Actors[ subject ], predicate_objects)<br><br>where Actors could even be an alias for window or global, or it&#39;s own registered namespace object. <br><br>The structure here also applies to the web application framework as well. Consider an endpoint that proxies XHR requests across another ESB. Let&#39;s say you&#39;re a ghetto-rigged organization using SMTP as your message bus. You could define an endpoint:<br><br>  get &#39;/smtp/:email&#39; -><br>          Smtp.send @email, @.req.body<br><br>Your email recipients, which could be a list of procmail scripts can then simply:<br><br>  process.stdin.resume()<br>  process.stdin.on &#39;data&#39;, (msg) -><br>          [subject,verb, predicate...] = JSON.parse msg<br>          global[subject]?[verb]?.apply(global[subject],predicate)<br><br>And you now have a functioning system that will allow you to invoke methods of objects on arbitrary machines across the world without much of anything. <br><br><br><br>  