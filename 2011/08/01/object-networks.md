Object Networks
===============

So here&#39;s not so much a prediction but a plan:<ul><li>objects will be modeled on the chip level</li><li>multi-dimensional arrays of objects will become the normative model of programming</li><li>new classes of objects will build the structure of the object network</li><li>wire objects will carry serialized messages across the matrix</li><li>hub objects will broadcast messages to peers</li><li>filter objects will be used in conjunction with hubs to implement switching</li><li>mixer objects will mux streams of messages to provide synchronization in async architectures</li><li>amplifier objects will augment messages with additional data</li><li>timer objects will provide localized synchronization for apps which require low jitter synchronization</li><li>typical communication between objects is fully asynchronous on a hardware level</li><li>limited access to external resources to necessitate heavy investment in graph based programming models for object networks</li><li>feedback loops will make thread locking look downright pleasant to debug</li></ul><br>This thinking is largely predicated on playing around with programming for the Green Arrays 144 core forth chip. The software engineering necessary to layout your application as a set of bite sized chunks over a 2d array of cores with interior cores having no access to the outside world, and ripple loading code from storage to each node. (think passing the baton from runner to runner, and the last runner keeps it until each runner has one). These realities make programming for multi-thousand core chips look less like programming web applications, or even networked erlang apps, but more like FPGA programming.  While computers will undoubtably take over routing message flows, programming will become more akin to gardening or sculpting than to what it looks like now. <br><br>In fact most parts of the core will have to have the default behavior of ignoring all incoming messages unless matching a special boot signal  This will because power efficiency can only be achieved if unused parts remain in a low power state. Many objects will only be used for data storage and retrieval, behind muxers, and will do nothing most of their time. 