JavaScript as OOLisP
====================

In porting Self to JavaScript, I have built an intermediate form of JavaScript which is effectively an object oriented Lisp. As each object is a function that evaluates its parameters as a method call to its own properties, the resulting structure resembles the body of a progn. The chaining of return value function calls provides a implicit context for resolving each expression.   Probably most curiously, the resultant program structure can be directly represented as arrays of strings, with resolution of globals being done through invocations of the form:<br><br>  (&#39;someGlobal&#39;)<br><br>Which cleanly evaluates to the related:<br><br>  window.someGlobal<br><br>From the standpoint of representing a program in memory, using the array trick we can represent it as:<br><br>  [&#39;someGlobal&#39;]<br><br>And simply rely upon Array.eval to do the right thing. In fact, all of Lisp can be implemented using a function that visits the members of the Array, calling .eval() on each sub array, and reducing the final product. If a shallow copy of the array is produced, this copy can be used in the final evaluation. <br><br>Which brings me to an interesting possibility. What if we had an editor in JavaScript which represented the entire program as nested arrays of mostly strings, and effectively used Lisp as a representation format?  It is all straight JavaScript, afterall, and the editor can simply manipulate structured representations of the program which are self-evaluating through the underlying object hierarchy. Rather than write programs in JavaScript, the editor would build programs in JavaScript objects. Serialization can simply use JSON as a method of storage, and since even functions can be represented in this manner, compilation is a side effect of evaluation. <br><br>If you look at my HTML.js, only the _ character is an explicit reference to an object, all else can be modeled as adjacent arrays. A rather simple rule to evaluate all arrays in a current context, would suffice to translate this idiom. In effect, _ is the operator to create a new context. Having the ability to nest object contexts replace lexical scope with objective scoping. Words only have meaning within the context object they are evaluated. This is itself a very interesting model for encapsulation, and one I need to spend more time exploring. 