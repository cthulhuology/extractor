Future of Software Engineering
==============================

If you look back 35 years ago, it was normal for programmers to wire up their own logic boards. Wire wrapped TTL gates were a simple way to build a functional system without resorting to an then archaic box of tubes. <br><br>25 years ago (holy crap, I&#39;ve been programming for 28 years!) it was common for programmers to roll their own assembler / compiler, and nearly every app included its own operating system to control disks, video, sound, and peripherals.  If you don&#39;t remember writing your own SB16 drivers and tweaking registers in your graphics card to find new resolutions, you missed out on real fun. <br><br>15 years ago, odds are you probably didn&#39;t write a lot of device drivers (unless you were working on linux) and you probably were finally dealing with networking in every project.  Writing web servers, and building IRC bots were typical for people coming out of the BBS scene.  Those of us who knew all of out AT commands for our Hayes modems got new toys to play with once we had networks of computers available. <br><br>10 years ago, you probably were programming in a language running on a VM somewhere other than your machine. Java, Flash, JavaScript, were all probable client side languages. Perl, Python and C/C++ were still dominant on the backend. By this point the typical project would involve programs written in 4-6 languages and would have web components, Java or Flash front ends, and C/C++ back ends with integrated scripting languages and a relational database with SQL. <br><br>5 years ago, most of those bits became abstracted with middleware, and ORMs became common place.  Most programmers stopped dealing with all of the levels of the stack.  Most programmers no longer wrote for any hardware in particular, and most systems were sufficiently divorced from the details of network programming that even the transport protocols were opaque to the user. <br><br>Now we are seeing a new shift to ubiquitous messaging. The typical programmer working today is dealing with routing messages to various layers of the infrastructure. Figuring out to to arrange topologies of queues or partitioning data across rings of distributed storage or persisting and streaming graph data have become core competencies. Are you spending your time coming up with indexing schemes for big data?  Guess what. <br><br>In 5 years most programmers won&#39;t know how to route messages or how to design a queuing topology.  The network will know how to route application level messages without the knowledge or interference of the programmer. <br><br>Within 10 years distributed object graphs will be abstracted out to the level where typical programmers won&#39;t even be aware of the topology issues. Middleware runtimes will dynamically search for and contact distributed swarms of persistent objects without user interaction<br><br>Within 15 years, ad hoc queries in natural language will replace most current programming tasks.  Expert computer systems will handle most of the mathematical problem solving by employing genetic algorithms with the programmer mostly relegated to the art of digital bonsai, pruning bits to get the general shape of the solution rather than implementing. <br><br>In 25 years, humans will largely program computers by interrogating them. Like a middle manager asking his employee to file a TPS report, human level intelligence in appliance form will be commonplace.  <br><br>35 years from now, people will marvel at the concept that people ever had to program computers, or build them by hand, or that people even had to drive their own cars, cut their own grass, or do laundry.   My grandchildren will grow up in a world where computing materials will be ubiquitous and the cost of computing will essentially be free. <br><br>The future of software engineering looks a lot more like the present state of landscape gardening. A few exceptional individuals will produce works of great beauty, but most will be employed in the simple maintenance of the natural growth of the media. Like tending any complex system made up of living things, our computing gardens will need tending, a steady hand, and a great deal of care. Raising AIs will be as important as raising our own children, and creating a nurturing environment for healthy growth will be the source of profit. 