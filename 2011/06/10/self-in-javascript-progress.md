Self in Javascript Progress
===========================

In the past two days, I&#39;ve started down two different approaches to representing Self objects in Javascript, and I&#39;m settling into a rather interesting representation:<br><br>  function () { return arguments.callee.eval.apply(arguments.callee,arguments); }<br><br>If you look at that for about 2 moments, it may not make sense until you look at the definition of "eval":<br><br>  Function.prototype.eval = function(selector) {<br>        return this[selector].apply(this,arguments.after(0));<br>  }<br><br>What this means is that eval does a dynamic message send by looking up the property of the function represented by the string "selector", and then invokes that method using the remainder of the arguments as the parameters to the method.  To define a method, I&#39;m currently leaning towards a simple routine:<br><br>  Function.prototype.does = function(selector,definition) {<br>        this[selector] = definition.compile();<br>        return this;<br>  }<br><br>Which simply compiles the definition for the given selector and adds it to the function object itself.  What this means is that we can invoke a method by doing something like:<br><br>  object("selector", ....)<br><br>Which will invoke in turn the method defined as:<br><br>  object.does("selector", "| console.log(&#39;hello world&#39;)");<br><br>Now I&#39;ve ditched the syntax for most function definitions and have started using something that looks a lot more like Self:<br><br>   &#39; x y | return x + y &#39;<br><br>Which the parameters are before the | and the string after the | is the body of the function which we can construct using:<br><br>  String.prototype.compile = function() {<br>        var parts = this.split("|");<br>        return Function.constructor.apply(Function,parts.shift().split(/\\s/).concat(parts.join("|")).filter(function(x) { return x != "" }))<br>  }<br><br>And at this point, we can start writing some pretty awesome looking javascript!  I&#39;ve got a utility function named _ which takes an optional global name to which to attach an object:<br><br>  _(&#39;foo&#39;)<br><br>Will create an object and name it &#39;foo&#39; in the global namespace so we can refer to it as foo.  If we were to write:<br><br>  _(&#39;foo&#39;).does(&#39;add:&#39;, "x | this(&#39;value:&#39;, x + this(&#39;value&#39;)); return this(&#39;value&#39;)").slot("value",10);<br><br>we would create an object with a method &#39;add: x&#39; and a slot &#39;value <- 10&#39;. We could evaluate it as:<br><br>  foo("add:",4); //  -> 14<br>  foo("add:",6); // -> 20<br>  foo("value"); // -> 20<br><br>At this point some bells should be going off as:<br><br>  foo add: 4.<br>  foo add: 6.<br>  foo value.<br><br>Is the equivalent Self. It is going to take a little more work to finish the translator, but a considerable amount of the language can be built using these idioms.<br><br><br><br><br>