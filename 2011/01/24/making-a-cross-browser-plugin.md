Making a cross browser plugin
=============================

This weekend I spent a few hours writing a browser plugin for webkit, and was surprised how easy it was to get up and running, and then equally surprised at the behavior. For kicks, I hooked up a listen on a port and accepted incomming tcp/ip connections and echoed back the content. This worked well for as long as the plugin was instantiated, but I could not reliably predict when it would be finalized. This meant that. Further testing is necessary, but it appears that the plugin is not finalized until the browser closes. <br /><br />If this is true, then it is trivial to write a small page that instantiates a plugin that provides JS with the infrastructure to run a node.js server. Or even better provide the means to run a node in a distributed key value store.  A cool proof of concept implementation would take the Amazon Dynamo paper and implement anpartitioned ring. In theory, if the plugin were used by enough high traffic sites, the robustness would improve as more nodes were added, and the size of any one node decreased. <br /><br />My intended use for all of this is to serve as a backing store for what I am building in Phos3D. Right now it looks like the code will only be a few k bytes and when compressed won&#39;t be that much smaller. What is going to take up space are all of the models, shaders, images, and user generated content. Having a nice way to store it across as many nodes as possible is a great idea. <br /><br />Hopefully this week I will port Jawas to live in a npapi environment and have an honest high performance cross platform webserver that can be embedded in most browsers. Then with Phos as the application framework and webgl as the rendering engine, I can build an large scale p2p distributed 3d world application using http and websockets in the browser only. Further more, with the webserver built into the client we can use the built in web db interface for all our storage needs. <br /><br />Then if you add in web workers, message events, and a decent routing layer, you can then have a distributed programming model, complete with free roaming intelligent agents. Since JavaScript is the one true run anywhere language, we cam leverage the power of the aggregate Internet (clients and all) to build much richer and larger applications. <br /><br />In the end, we might end up with the Shadowrun / Neuromancer matrix sooner than expected.