Java is not Object Oriented
===========================

So yesterday I spent the entire day playing with Java&#39;s reflection capabilities, which are with out a doubt as developed as a new born babe. The language itself trips over it&#39;s own feet, and as such a programmer can not assume basic operations will not throw exceptions. <br /><br />Take for example, Method.invoke(target, args) which can only be used if you Method.getParameterTypes() iterate over the Class[] array, and then inspect each argument to see if it matches, or can be substituted for via a proxy, and then maybe you can dispatch. Watch out for java.lang.exception.JavaIsNotObjectOrientedAndBlowsupWhenUsingPolymorphism<br />because after checking your args not all objects are objects and can recieve thee necessary reflection methods. <br /><br />Compare Java&#39;s reflection to Smalltalk&#39;s is like warping back in time to the early 80s and discovering run time reflection to be a novel idea. This of course still doesn&#39;t mean Java&#39;s Object (which is not the base class of all objects) has no sane way to implement perform:with: or my personal favorite perform:withArgs: which is sort of like what you can hack with invoke but never really works. <br /><br />Now we could say that Java could not possibly have these features fully baked at it&#39;s inception and had to be bolted on much later, but that ignores the simple history of Smalltalk and Sun and the Self language at Sun, and the fact that the Hotspot VM was built based on the Self VM. No it was not that it couldn&#39;t, it was because of marketing. <br /><br />Now JavaScript, whose object model comes directly from Self, has petty wonderful reflection capabilities. I have already implemented mirrors in Phos, and use behavioralism extensively in my applications. Most of my production code relies upon reflection in order to either auto-bind library calls to scripting languages, or to dynamically extend a system at run time via plugins. If you ever do anything interesting with multiple languages you will quickly realize reflection allows you to have the computer replace thousands of lines of boilerplate, with a small ABI wrapper. IDLs suck because they take humans to sort out things the computer already knows. Reflection does not suck because it allows the computer to tell the programmer something he didn&#39;t. <br /><br />Java makes both painful.