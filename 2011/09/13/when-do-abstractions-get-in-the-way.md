When Do Abstractions Get In The Way
===================================

Over the past few days, I&#39;ve been writing a lot. I&#39;m about 3 chapters into my latest book, and I am still wading through the basics. Why has it taken so many pages to get to a point where the book is almost ready to start?  Why do I feel compelled to drag my reader through a morass of abstractions, caveats, and history there of?<br><br>Because I am trying to make it concrete. <br><br>Rather than focus on the semantics and the idealized representation, I am walking through actual code, focusing on the bits one can see. Rather than get into the theory, I focus on the history, the sets of accidents that define how we got into our current mess. Often in the process of learning things, it is more useful to know what begot what and who did what, than to know what someone&#39;s actual reasoning was. The reason is reality. Causality tends to trump all reason. <br><br>For example take any idiosyncratic behavior in a specification, where the style of the thing is radically different from it&#39;s predecessor. In general the reason for the change is historical, where by the commingling of two previously extant things results in an unsatisfactory compromise.  XHTML Is a great example only overshadowed by CSS.   Think about all of the historical baggage we carry with us that is a product of the divorce between style and substance. The bastard offspring are still confused about their roles. We may have slain the blink tag, but just try to remove bold or italics. <br><br>We have anachronisms built into nearly everything we do. Convention is rarely based upon a well reasoned and researched rationale. Convention is the mere aggregation of culture, a pattern repeated enough times by enough individuals that it acquires an independent identity. Languages become popular because they appeal to a preexisting cultural bias, and not because they are quantitatively better, like most people don&#39;t date someone because their particular genetic makeup will have the maximum potential for successful offspring. (we in fact have a cultural bias against this we call "playing god" even though we do it with nearly every other species we find useful).  Ruby became popular because it was Perlish enough but with a Smalltalkish OO built in. People who felt like OO in Perl was too painful switched to Ruby. Those who wanted Lisp w/ syntax were already busy programming in Python. And the ones who didn&#39;t enjoy programming in the first place were writing Java anyways. (gluttons for punishment)<br><br>If you focus too much on the abstraction, you&#39;ll miss the very human reason things are this way and not some other. <br><br><br><br>